NAME
       gcc - GNU project C and C++ compiler

SYNOPSIS
       gcc [-c|-S|-E] [-std=standard]
           [-g] [-pg] [-Olevel]
           [-Wwarn...] [-Wpedantic]
           [-Idir...] [-Ldir...]
           [-Dmacro[=defn]...] [-Umacro]
           [-foption...] [-mmachine-option...]
           [-o outfile] [@file] infile...

DESCRIPTION
-c option says not to run the linker.

if you specify -L more than once, the directories are searched in the order specified.  Also, the placement of the -l option is significant.

OPTIONS
   Option Summary
       Overall Options
           -c  -S  -E  -o file  -no-canonical-prefixes -pipe  -pass-exit-codes -x language  -v  -###  --help[=class[,...]]  --target-help --version -wrapper @file -fplugin=file -fplugin-arg-name=arg -fdump-ada-spec[-slim] -fada-spec-parent=unit -fdump-go-spec=file

       C Language Options
           -ansi  -std=standard  -fgnu89-inline -aux-info filename -fallow-parameterless-variadic-functions -fno-asm  -fno-builtin  -fno-builtin-function -fhosted  -ffreestanding -fopenmp -fopenmp-simd -fms-extensions -fplan9-extensions -trigraphs  -traditional  -traditional-cpp -fallow-single-precision  -fcond-mismatch -flax-vector-conversions -fsigned-bitfields  -fsigned-char -funsigned-bitfields  -funsigned-char

       Preprocessor Options
           -Aquestion=answer -A-question[=answer] -C  -dD  -dI  -dM  -dN -Dmacro[=defn]  -E  -H -idirafter dir -include file  -imacros file -iprefix file  -iwithprefix dir -iwithprefixbefore dir  -isystem dir -imultilib dir -isysroot dir -M  -MM  -MF  -MG  -MP  -MQ  -MT  -nostdinc -P  -fdebug-cpp -ftrack-macro-expansion -fworking-directory -remap -trigraphs  -undef  -Umacro -Wp,option -Xpreprocessor option -no-integrated-cpp

       Assembler Option
           -Wa,option  -Xassembler option

       Linker Options
           object-file-name  -llibrary -nostartfiles  -nodefaultlibs  -nostdlib -pie -rdynamic -s  -static -static-libgcc -static-libstdc++ -static-libasan -static-libtsan -static-liblsan -static-libubsan -shared -shared-libgcc  -symbolic -T script  -Wl,option  -Xlinker option -u symbol

           i386 and x86-64 Options -mtune=cpu-type  -march=cpu-type -mtune-ctrl=feature-list -mdump-tune-features -mno-default -mfpmath=unit -masm=dialect  -mno-fancy-math-387 -mno-fp-ret-in-387  -msoft-float -mno-wide-multiply  -mrtd  -malign-double -mpreferred-stack-boundary=num -mincoming-stack-boundary=num -mcld -mcx16 -msahf -mmovbe -mcrc32 -mrecip -mrecip=opt -mvzeroupper -mprefer-avx128 -mmmx  -msse  -msse2 -msse3 -mssse3 -msse4.1 -msse4.2 -msse4 -mavx -mavx2 -mavx512f -mavx512pf -mavx512er -mavx512cd -msha -maes -mpclmul -mfsgsbase -mrdrnd -mf16c -mfma -mprefetchwt1 -msse4a -m3dnow -mpopcnt -mabm -mbmi -mtbm -mfma4 -mxop -mlzcnt -mbmi2 -mfxsr -mxsave -mxsaveopt -mrtm -mlwp -mthreads -mno-align-stringops  -minline-all-stringops -minline-stringops-dynamically -mstringop-strategy=alg -mmemcpy-strategy=strategy -mmemset-strategy=strategy -mpush-args  -maccumulate-outgoing-args  -m128bit-long-double -m96bit-long-double -mlong-double-64 -mlong-double-80 -mlong-double-128 -mregparm=num  -msseregparm -mveclibabi=type -mvect8-ret-in-mem -mpc32 -mpc64 -mpc80 -mstackrealign -momit-leaf-frame-pointer  -mno-red-zone -mno-tls-direct-seg-refs -mcmodel=code-model -mabi=name -maddress-mode=mode -m32 -m64 -mx32 -m16 -mlarge-data-threshold=num -msse2avx -mfentry -m8bit-idiv -mavx256-split-unaligned-load -mavx256-split-unaligned-store -mstack-protector-guard=guard

           i386 and x86-64 Windows Options -mconsole -mcygwin -mno-cygwin -mdll -mnop-fun-dllimport -mthread -municode -mwin32 -mwindows -fno-set-stack-executable


   Options Controlling the Kind of Output
       Compilation can involve up to four stages: preprocessing, compilation proper, assembly and linking.

       For any given input file, the file name suffix determines what kind of compilation is done:

       file.c
           C source code that must be preprocessed.

       file.i
           C source code that should not be preprocessed.

       file.h
           C, C++, Objective-C or Objective-C++ header file to be turned into a precompiled header (default), or C, C++ header file to be turned into an Ada spec (via the -fdump-ada-spec switch).


       file.s
           Assembler code.

       file.S
           Assembler code that must be preprocessed.

use filename suffixes to tell gcc where to start, and one of the options -c, -S, or -E to say where gcc is to stop.

       -c  Compile or assemble the source files, but do not link.

       -S  Stop after the stage of compilation proper; do not assemble. The output is in the form of an assembler code.

       -E  Stop after the preprocessing stage; do not run the compiler proper.

       -o file
           Place output in file file.
           
       -v  Print (on standard error output) the commands executed to run the stages of compilation.

       -###
           Like -v except the commands are not executed and arguments are quoted. Useful for shell scripts.



   Options to Request or Suppress Warnings
       -fsyntax-only
           Check the code for syntax errors, but don't do anything beyond that.

       -w  Inhibit all warning messages.

       -Werror
           Make all warnings into errors.

       -Wall
           This enables all the warnings.


   Options for Debugging Your Program or GCC
       GCC has various special options that are used for debugging either your program or GCC:

       -g  Produce debugging information in the operating system's native format (stabs, COFF, XCOFF, or DWARF 2).  GDB can work with this debugging information.

           On most systems that use stabs format, -g enables use of extra debugging information that only GDB can use; this extra information makes debugging work better in GDB but probably makes other debuggers crash or refuse to read the program.  If you want to control for certain whether to generate the extra information, use -gstabs+, -gstabs, -gxcoff+, -gxcoff, or -gvms (see below).

           GCC allows you to use -g with -O.  The shortcuts taken by optimized code may occasionally produce surprising results: some variables you declared may not exist at all; flow of control may briefly move where you did not expect it; some statements may not be executed because they compute constant results or their values are already at hand; some statements may execute in different places because they have been moved out of loops.

           Nevertheless it proves possible to debug optimized output.  This makes it reasonable to use the optimizer for programs that might have bugs.

           The following options are useful when GCC is generated with the capability for more than one debugging format.

       -gsplit-dwarf
           Separate as much dwarf debugging information as possible into a separate output file with the extension .dwo.  This option allows the build system to avoid linking files with debug information.  To be useful, this option requires a debugger capable of reading .dwo files.

       -ggdb
           Produce debugging information for use by GDB.  This means to use the most expressive format available (DWARF 2, stabs, or the native format if neither of those are supported), including GDB extensions if at all possible.

       -gpubnames
           Generate dwarf .debug_pubnames and .debug_pubtypes sections.

       -ggnu-pubnames
           Generate .debug_pubnames and .debug_pubtypes sections in a format suitable for conversion into a GDB index.  This option is only useful with a linker that can produce GDB index version 7.

       -gstabs
           Produce debugging information in stabs format (if that is supported), without GDB extensions.  This is the format used by DBX on most BSD systems.  On MIPS, Alpha and System V Release 4 systems this option produces stabs debugging output that is not understood by DBX or SDB.  On System V Release 4 systems this option requires the GNU assembler.

       -feliminate-unused-debug-symbols
           Produce debugging information in stabs format (if that is supported), for only symbols that are actually used.

       -femit-class-debug-always
           Instead of emitting debugging information for a C++ class in only one object file, emit it in all object files using the class.  This option should be used only with debuggers that are unable to handle the way GCC normally emits debugging information for classes because using this option increases the size of debugging information by as much as a factor of two.

       -fdebug-types-section
           When using DWARF Version 4 or higher, type DIEs can be put into their own ".debug_types" section instead of making them part of the ".debug_info" section.  It is more efficient to put them in a separate comdat sections since the linker can then remove duplicates.  But not all DWARF consumers support ".debug_types" sections yet and on some objects ".debug_types" produces larger instead of smaller debugging information.

       -gstabs+
           Produce debugging information in stabs format (if that is supported), using GNU extensions understood only by the GNU debugger (GDB).  The use of these extensions is likely to make other debuggers crash or refuse to read the program.

       -gcoff
           Produce debugging information in COFF format (if that is supported).  This is the format used by SDB on most System V systems prior to System V Release 4.

       -gxcoff
           Produce debugging information in XCOFF format (if that is supported).  This is the format used by the DBX debugger on IBM RS/6000 systems.

       -gxcoff+
           Produce debugging information in XCOFF format (if that is supported), using GNU extensions understood only by the GNU debugger (GDB).  The use of these extensions is likely to make other debuggers crash or refuse to read the program, and may cause assemblers other than the GNU assembler (GAS) to fail with an error.

       -gdwarf-version
           Produce debugging information in DWARF format (if that is supported).  The value of version may be either 2, 3 or 4; the default version for most targets is 4.

           Note that with DWARF Version 2, some ports require and always use some non-conflicting DWARF 3 extensions in the unwind tables.

           Version 4 may require GDB 7.0 and -fvar-tracking-assignments for maximum benefit.

       -grecord-gcc-switches
           This switch causes the command-line options used to invoke the compiler that may affect code generation to be appended to the DW_AT_producer attribute in DWARF debugging information.  The options are concatenated with spaces separating them from each other and from the compiler version.  See also -frecord-gcc-switches for another way of storing compiler options into the object file.  This is the default.

       -gno-record-gcc-switches
           Disallow appending command-line options to the DW_AT_producer attribute in DWARF debugging information.

       -gstrict-dwarf
           Disallow using extensions of later DWARF standard version than selected with -gdwarf-version.  On most targets using non-conflicting DWARF extensions from later standard versions is allowed.

       -gno-strict-dwarf
           Allow using extensions of later DWARF standard version than selected with -gdwarf-version.

       -gvms
           Produce debugging information in Alpha/VMS debug format (if that is supported).  This is the format used by DEBUG on Alpha/VMS systems.

       -glevel
       -ggdblevel
       -gstabslevel
       -gcofflevel
       -gxcofflevel
       -gvmslevel
           Request debugging information and also use level to specify how much information.  The default level is 2.

           Level 0 produces no debug information at all.  Thus, -g0 negates -g.

           Level 1 produces minimal information, enough for making backtraces in parts of the program that you don't plan to debug.  This includes descriptions of functions and external variables, and line number tables, but no information about local variables.

           Level 3 includes extra information, such as all the macro definitions present in the program.  Some debuggers support macro expansion when you use -g3.

           -gdwarf-2 does not accept a concatenated debug level, because GCC used to support an option -gdwarf that meant to generate debug information in version 1 of the DWARF format (which is very different from version 2), and it would have been too confusing.  That debug format is long obsolete, but the option cannot be changed now.  Instead use an additional -glevel option to change the debug level for DWARF.

       -gtoggle
           Turn off generation of debug info, if leaving out this option generates it, or turn it on at level 2 otherwise.  The position of this argument in the command line does not matter; it takes effect after all other options are processed, and it does so only once, no matter how many times it is given.  This is mainly intended to be used with -fcompare-debug.

       -fsanitize=address
           Enable AddressSanitizer, a fast memory error detector.  Memory access instructions will be instrumented to detect out-of-bounds and use-after-free bugs.  See <http://code.google.com/p/address-sanitizer/> for more details.  The run-time behavior can be influenced using the ASAN_OPTIONS environment variable; see <https://code.google.com/p/address-sanitizer/wiki/Flags#Run-time_flags> for a list of supported options.

       -fsanitize=kernel-address
           Enable AddressSanitizer for Linux kernel.  See <http://code.google.com/p/address-sanitizer/wiki/AddressSanitizerForKernel> for more details.

       -fsanitize=thread
           Enable ThreadSanitizer, a fast data race detector.  Memory access instructions will be instrumented to detect data race bugs.  See <http://code.google.com/p/thread-sanitizer/> for more details. The run-time behavior can be influenced using the TSAN_OPTIONS environment variable; see <https://code.google.com/p/thread-sanitizer/wiki/Flags> for a list of supported options.

       -fsanitize=leak
           Enable LeakSanitizer, a memory leak detector.  This option only matters for linking of executables and if neither -fsanitize=address nor -fsanitize=thread is used.  In that case it will link the executable against a library that overrides "malloc" and other allocator functions.  See <https://code.google.com/p/address-sanitizer/wiki/LeakSanitizer> for more details.  The run-time behavior can be influenced using the LSAN_OPTIONS environment variable.

       -fsanitize=undefined
           Enable UndefinedBehaviorSanitizer, a fast undefined behavior detector.  Various computations will be instrumented to detect undefined behavior at runtime.  Current suboptions are:

           -fsanitize=shift
               This option enables checking that the result of a shift operation is not undefined.  Note that what exactly is considered undefined differs slightly between C and C++, as well as between ISO C90 and C99, etc.

           -fsanitize=integer-divide-by-zero
               Detect integer division by zero as well as "INT_MIN / -1" division.

           -fsanitize=unreachable
               With this option, the compiler will turn the "__builtin_unreachable" call into a diagnostics message call instead.  When reaching the "__builtin_unreachable" call, the behavior is undefined.

           -fsanitize=vla-bound
               This option instructs the compiler to check that the size of a variable length array is positive.  This option does not have any effect in -std=c++1y mode, as the standard requires the exception be thrown instead.

           -fsanitize=null
               This option enables pointer checking.  Particularly, the application built with this option turned on will issue an error message when it tries to dereference a NULL pointer, or if a reference (possibly an rvalue reference) is bound to a NULL pointer.

           -fsanitize=return
               This option enables return statement checking.  Programs built with this option turned on will issue an error message when the end of a non-void function is reached without actually returning a value.  This option works in C++ only.

           -fsanitize=signed-integer-overflow
               This option enables signed integer overflow checking.  We check that the result of "+", "*", and both unary and binary "-" does not overflow in the signed arithmetics.  Note, integer promotion rules must be taken into account.  That is, the following is not an overflow:

                       signed char a = SCHAR_MAX;
                       a++;

           While -ftrapv causes traps for signed overflows to be emitted, -fsanitize=undefined gives a diagnostic message.  This currently works only for the C family of languages.

       -fdump-final-insns[=file]
           Dump the final internal representation (RTL) to file.  If the optional argument is omitted (or if file is "."), the name of the dump file is determined by appending ".gkd" to the compilation output file name.

       -fcompare-debug[=opts]
           If no error occurs during compilation, run the compiler a second time, adding opts and -fcompare-debug-second to the arguments passed to the second compilation.  Dump the final internal representation in both compilations, and print an error if they differ.

           If the equal sign is omitted, the default -gtoggle is used.

           The environment variable GCC_COMPARE_DEBUG, if defined, non-empty and nonzero, implicitly enables -fcompare-debug.  If GCC_COMPARE_DEBUG is defined to a string starting with a dash, then it is used for opts, otherwise the default -gtoggle is used.

           -fcompare-debug=, with the equal sign but without opts, is equivalent to -fno-compare-debug, which disables the dumping of the final representation and the second compilation, preventing even GCC_COMPARE_DEBUG from taking effect.

           To verify full coverage during -fcompare-debug testing, set GCC_COMPARE_DEBUG to say -fcompare-debug-not-overridden, which GCC rejects as an invalid option in any actual compilation (rather than preprocessing, assembly or linking).  To get just a warning, setting GCC_COMPARE_DEBUG to -w%n-fcompare-debug not overridden will do.

       -fcompare-debug-second
           This option is implicitly passed to the compiler for the second compilation requested by -fcompare-debug, along with options to silence warnings, and omitting other options that would cause side-effect compiler outputs to files or to the standard output.  Dump files and preserved temporary files are renamed so as to contain the ".gk" additional extension during the second compilation, to avoid overwriting those generated by the first.

           When this option is passed to the compiler driver, it causes the first compilation to be skipped, which makes it useful for little other than debugging the compiler proper.

       -feliminate-dwarf2-dups
           Compress DWARF 2 debugging information by eliminating duplicated information about each symbol.  This option only makes sense when generating DWARF 2 debugging information with -gdwarf-2.

       -femit-struct-debug-baseonly
           Emit debug information for struct-like types only when the base name of the compilation source file matches the base name of file in which the struct is defined.

           This option substantially reduces the size of debugging information, but at significant potential loss in type information to the debugger.  See -femit-struct-debug-reduced for a less aggressive option.  See -femit-struct-debug-detailed for more detailed control.

           This option works only with DWARF 2.

       -femit-struct-debug-reduced
           Emit debug information for struct-like types only when the base name of the compilation source file matches the base name of file in which the type is defined, unless the struct is a template or defined in a system header.

           This option significantly reduces the size of debugging information, with some potential loss in type information to the debugger.  See -femit-struct-debug-baseonly for a more aggressive option.  See -femit-struct-debug-detailed for more detailed control.

           This option works only with DWARF 2.

       -femit-struct-debug-detailed[=spec-list]
           Specify the struct-like types for which the compiler generates debug information.  The intent is to reduce duplicate struct debug information between different object files within the same program.

           This option is a detailed version of -femit-struct-debug-reduced and -femit-struct-debug-baseonly, which serves for most needs.

           A specification has the syntax[dir:|ind:][ord:|gen:](any|sys|base|none)

           The optional first word limits the specification to structs that are used directly (dir:) or used indirectly (ind:).  A struct type is used directly when it is the type of a variable, member.  Indirect uses arise through pointers to structs.  That is, when use of an incomplete struct is valid, the use is indirect.  An example is struct one direct; struct two * indirect;.

           The optional second word limits the specification to ordinary structs (ord:) or generic structs (gen:).  Generic structs are a bit complicated to explain.  For C++, these are non-explicit specializations of template classes, or non-template classes within the above.  Other programming languages have generics, but -femit-struct-debug-detailed does not yet implement them.

           The third word specifies the source files for those structs for which the compiler should emit debug information.  The values none and any have the normal meaning.  The value base means that the base of name of the file in which the type declaration appears must match the base of the name of the main compilation file.  In practice, this means that when compiling foo.c, debug information is generated for types declared in that file and foo.h, but not other header files.  The value sys means those types satisfying base or declared in system or compiler headers.

           You may need to experiment to determine the best settings for your application.

           The default is -femit-struct-debug-detailed=all.

           This option works only with DWARF 2.

       -fno-merge-debug-strings
           Direct the linker to not merge together strings in the debugging information that are identical in different object files.  Merging is not supported by all assemblers or linkers.  Merging decreases the size of the debug information in the output file at the cost of increasing link processing time.  Merging is enabled by default.

       -fdebug-prefix-map=old=new
           When compiling files in directory old, record debugging information describing them as in new instead.

       -fno-dwarf2-cfi-asm
           Emit DWARF 2 unwind info as compiler generated ".eh_frame" section instead of using GAS ".cfi_*" directives.

       -p  Generate extra code to write profile information suitable for the analysis program prof.  You must use this option when compiling the source files you want data about, and you must also use it when linking.

       -pg Generate extra code to write profile information suitable for the analysis program gprof.  You must use this option when compiling the source files you want data about, and you must also use it when linking.

       -Q  Makes the compiler print out each function name as it is compiled, and print some statistics about each pass when it finishes.

       -ftime-report
           Makes the compiler print some statistics about the time consumed by each pass when it finishes.

       -fmem-report
           Makes the compiler print some statistics about permanent memory allocation when it finishes.

       -fmem-report-wpa
           Makes the compiler print some statistics about permanent memory allocation for the WPA phase only.

       -fpre-ipa-mem-report
       -fpost-ipa-mem-report
           Makes the compiler print some statistics about permanent memory allocation before or after interprocedural optimization.

       -fprofile-report
           Makes the compiler print some statistics about consistency of the (estimated) profile and effect of individual passes.

       -fstack-usage
           Makes the compiler output stack usage information for the program, on a per-function basis.  The filename for the dump is made by appending .su to the auxname.  auxname is generated from the name of the output file, if explicitly specified and it is not an executable, otherwise it is the basename of the source file.  An entry is made up of three fields:

           ·   The name of the function.

           ·   A number of bytes.

           ·   One or more qualifiers: "static", "dynamic", "bounded".

           The qualifier "static" means that the function manipulates the stack statically: a fixed number of bytes are allocated for the frame on function entry and released on function exit; no stack adjustments are otherwise made in the function.  The second field is this fixed number of bytes.

           The qualifier "dynamic" means that the function manipulates the stack dynamically: in addition to the static allocation described above, stack adjustments are made in the body of the function, for example to push/pop arguments around function calls.  If the qualifier "bounded" is also present, the amount of these adjustments is bounded at compile time and the second field is an upper bound of the total amount of stack used by the function.  If it is not present, the amount of these adjustments is not bounded at compile time and the second field only represents the bounded part.

       -fprofile-arcs
           Add code so that program flow arcs are instrumented.  During execution the program records how many times each branch and call is executed and how many times it is taken or returns.  When the compiled program exits it saves this data to a file called auxname.gcda for each source file.  The data may be used for profile-directed optimizations (-fbranch-probabilities), or for test coverage analysis (-ftest-coverage).  Each object file's auxname is generated from the name of the output file, if explicitly specified and it is not the final executable, otherwise it is the basename of the source file.  In both cases any suffix is removed (e.g. foo.gcda for input file dir/foo.c, or dir/foo.gcda for output file specified as -o dir/foo.o).

       --coverage
           This option is used to compile and link code instrumented for coverage analysis.  The option is a synonym for -fprofile-arcs -ftest-coverage (when compiling) and -lgcov (when linking).  See the documentation for those options for more details.

           ·   Compile the source files with -fprofile-arcs plus optimization and code generation options.  For test coverage analysis, use the additional -ftest-coverage option.  You do not need to profile every source file in a program.

           ·   Link your object files with -lgcov or -fprofile-arcs (the latter implies the former).

           ·   Run the program on a representative workload to generate the arc profile information.  This may be repeated any number of times.  You can run concurrent instances of your program, and provided that the file system supports locking, the data files will be correctly updated.  Also "fork" calls are detected and correctly handled (double counting will not happen).

           ·   For profile-directed optimizations, compile the source files again with the same optimization and code generation options plus -fbranch-probabilities.

           ·   For test coverage analysis, use gcov to produce human readable information from the .gcno and .gcda files.  Refer to the gcov documentation for further information.

           With -fprofile-arcs, for each function of your program GCC creates a program flow graph, then finds a spanning tree for the graph.  Only arcs that are not on the spanning tree have to be instrumented: the compiler adds code to count the number of times that these arcs are executed.  When an arc is the only exit or only entrance to a block, the instrumentation code can be added to the block; otherwise, a new basic block must be created to hold the instrumentation code.

       -ftest-coverage
           Produce a notes file that the gcov code-coverage utility can use to show program coverage.  Each source file's note file is called auxname.gcno.  Refer to the -fprofile-arcs option above for a description of auxname and instructions on how to generate test coverage data.  Coverage data matches the source files more closely if you do not optimize.

       -fdbg-cnt-list
           Print the name and the counter upper bound for all debug counters.

       -fdbg-cnt=counter-value-list
           Set the internal debug counter upper bound.  counter-value-list is a comma-separated list of name:value pairs which sets the upper bound of each debug counter name to value.  All debug counters have the initial upper bound of "UINT_MAX"; thus "dbg_cnt()" returns true always unless the upper bound is set by this option.  For example, with -fdbg-cnt=dce:10,tail_call:0, "dbg_cnt(dce)" returns true only for first 10 invocations.

       -fenable-kind-pass
       -fdisable-kind-pass=range-list
           This is a set of options that are used to explicitly disable/enable optimization passes.  These options are intended for use for debugging GCC.  Compiler users should use regular options for enabling/disabling passes instead.

           -fdisable-ipa-pass
               Disable IPA pass pass. pass is the pass name.  If the same pass is statically invoked in the compiler multiple times, the pass name should be appended with a sequential number starting from 1.

           -fdisable-rtl-pass
           -fdisable-rtl-pass=range-list
               Disable RTL pass pass.  pass is the pass name.  If the same pass is statically invoked in the compiler multiple times, the pass name should be appended with a sequential number starting from 1.  range-list is a comma-separated list of function ranges or assembler names.  Each range is a number pair separated by a colon.  The range is inclusive in both ends.  If the range is trivial, the number pair can be simplified as a single number.  If the function's call graph node's uid falls within one of the specified ranges, the pass is disabled for that function.  The uid is shown in the function header of a dump file, and the pass names can be dumped by using option -fdump-passes.

           -fdisable-tree-pass
           -fdisable-tree-pass=range-list
               Disable tree pass pass.  See -fdisable-rtl for the description of option arguments.

           -fenable-ipa-pass
               Enable IPA pass pass.  pass is the pass name.  If the same pass is statically invoked in the compiler multiple times, the pass name should be appended with a sequential number starting from 1.

           -fenable-rtl-pass
           -fenable-rtl-pass=range-list
               Enable RTL pass pass.  See -fdisable-rtl for option argument description and examples.

           -fenable-tree-pass
           -fenable-tree-pass=range-list
               Enable tree pass pass.  See -fdisable-rtl for the description of option arguments.

           Here are some examples showing uses of these options.

                   # disable ccp1 for all functions
                      -fdisable-tree-ccp1
                   # disable complete unroll for function whose cgraph node uid is 1
                      -fenable-tree-cunroll=1
                   # disable gcse2 for functions at the following ranges [1,1],
                   # [300,400], and [400,1000]
                   # disable gcse2 for functions foo and foo2
                      -fdisable-rtl-gcse2=foo,foo2
                   # disable early inlining
                      -fdisable-tree-einline
                   # disable ipa inlining
                      -fdisable-ipa-inline
                   # enable tree full unroll
                      -fenable-tree-unroll

       -dletters
       -fdump-rtl-pass
       -fdump-rtl-pass=filename
           Says to make debugging dumps during compilation at times specified by letters.  This is used for debugging the RTL-based passes of the compiler.  The file names for most of the dumps are made by appending a pass number and a word to the dumpname, and the files are created in the directory of the output file. In case of =filename option, the dump is output on the given file instead of the pass numbered dump files. Note that the pass number is computed statically as passes get registered into the pass manager.  Thus the numbering is not related to the dynamic order of execution of passes.  In particular, a pass installed by a plugin could have a number over 200 even if it executed quite early.  dumpname is generated from the name of the output file, if explicitly specified and it is not an executable, otherwise it is the basename of the source file. These switches may have different effects when -E is used for preprocessing.

           Debug dumps can be enabled with a -fdump-rtl switch or some -d option letters.  Here are the possible letters for use in pass and letters, and their meanings:

           -fdump-rtl-alignments
               Dump after branch alignments have been computed.

           -fdump-rtl-asmcons
               Dump after fixing rtl statements that have unsatisfied in/out constraints.

           -fdump-rtl-auto_inc_dec
               Dump after auto-inc-dec discovery.  This pass is only run on architectures that have auto inc or auto dec instructions.

           -fdump-rtl-barriers
               Dump after cleaning up the barrier instructions.

           -fdump-rtl-bbpart
               Dump after partitioning hot and cold basic blocks.

           -fdump-rtl-bbro
               Dump after block reordering.

           -fdump-rtl-btl1
           -fdump-rtl-btl2
               -fdump-rtl-btl1 and -fdump-rtl-btl2 enable dumping after the two branch target load optimization passes.

           -fdump-rtl-bypass
               Dump after jump bypassing and control flow optimizations.

           -fdump-rtl-combine
               Dump after the RTL instruction combination pass.

           -fdump-rtl-compgotos
               Dump after duplicating the computed gotos.

           -fdump-rtl-ce1
           -fdump-rtl-ce2
           -fdump-rtl-ce3
               -fdump-rtl-ce1, -fdump-rtl-ce2, and -fdump-rtl-ce3 enable dumping after the three if conversion passes.

           -fdump-rtl-cprop_hardreg
               Dump after hard register copy propagation.

           -fdump-rtl-csa
               Dump after combining stack adjustments.

           -fdump-rtl-cse1
           -fdump-rtl-cse2
               -fdump-rtl-cse1 and -fdump-rtl-cse2 enable dumping after the two common subexpression elimination passes.

           -fdump-rtl-dce
               Dump after the standalone dead code elimination passes.

           -fdump-rtl-dbr
               Dump after delayed branch scheduling.

           -fdump-rtl-dce1
           -fdump-rtl-dce2
               -fdump-rtl-dce1 and -fdump-rtl-dce2 enable dumping after the two dead store elimination passes.

           -fdump-rtl-eh
               Dump after finalization of EH handling code.

           -fdump-rtl-eh_ranges
               Dump after conversion of EH handling range regions.

           -fdump-rtl-expand
               Dump after RTL generation.

           -fdump-rtl-fwprop1
           -fdump-rtl-fwprop2
               -fdump-rtl-fwprop1 and -fdump-rtl-fwprop2 enable dumping after the two forward propagation passes.

           -fdump-rtl-gcse1
           -fdump-rtl-gcse2
               -fdump-rtl-gcse1 and -fdump-rtl-gcse2 enable dumping after global common subexpression elimination.

           -fdump-rtl-init-regs
               Dump after the initialization of the registers.

           -fdump-rtl-initvals
               Dump after the computation of the initial value sets.

           -fdump-rtl-into_cfglayout
               Dump after converting to cfglayout mode.

           -fdump-rtl-ira
               Dump after iterated register allocation.

           -fdump-rtl-jump
               Dump after the second jump optimization.

           -fdump-rtl-loop2
               -fdump-rtl-loop2 enables dumping after the rtl loop optimization passes.

           -fdump-rtl-mach
               Dump after performing the machine dependent reorganization pass, if that pass exists.

           -fdump-rtl-mode_sw
               Dump after removing redundant mode switches.

           -fdump-rtl-rnreg
               Dump after register renumbering.

           -fdump-rtl-outof_cfglayout
               Dump after converting from cfglayout mode.

           -fdump-rtl-peephole2
               Dump after the peephole pass.

           -fdump-rtl-postreload
               Dump after post-reload optimizations.

           -fdump-rtl-pro_and_epilogue
               Dump after generating the function prologues and epilogues.

           -fdump-rtl-sched1
           -fdump-rtl-sched2
               -fdump-rtl-sched1 and -fdump-rtl-sched2 enable dumping after the basic block scheduling passes.

           -fdump-rtl-ree
               Dump after sign/zero extension elimination.

           -fdump-rtl-seqabstr
               Dump after common sequence discovery.

           -fdump-rtl-shorten
               Dump after shortening branches.

           -fdump-rtl-sibling
               Dump after sibling call optimizations.

           -fdump-rtl-split1
           -fdump-rtl-split2
           -fdump-rtl-split3
           -fdump-rtl-split4
           -fdump-rtl-split5
               -fdump-rtl-split1, -fdump-rtl-split2, -fdump-rtl-split3, -fdump-rtl-split4 and -fdump-rtl-split5 enable dumping after five rounds of instruction splitting.

           -fdump-rtl-sms
               Dump after modulo scheduling.  This pass is only run on some architectures.

           -fdump-rtl-stack
               Dump after conversion from GCC's "flat register file" registers to the x87's stack-like registers.  This pass is only run on x86 variants.

           -fdump-rtl-subreg1
           -fdump-rtl-subreg2
               -fdump-rtl-subreg1 and -fdump-rtl-subreg2 enable dumping after the two subreg expansion passes.

           -fdump-rtl-unshare
               Dump after all rtl has been unshared.

           -fdump-rtl-vartrack
               Dump after variable tracking.

           -fdump-rtl-vregs
               Dump after converting virtual registers to hard registers.

           -fdump-rtl-web
               Dump after live range splitting.

           -fdump-rtl-regclass
           -fdump-rtl-subregs_of_mode_init
           -fdump-rtl-subregs_of_mode_finish
           -fdump-rtl-dfinit
           -fdump-rtl-dfinish
               These dumps are defined but always produce empty files.

           -da
           -fdump-rtl-all
               Produce all the dumps listed above.

           -dA Annotate the assembler output with miscellaneous debugging information.

           -dD Dump all macro definitions, at the end of preprocessing, in addition to normal output.

           -dH Produce a core dump whenever an error occurs.

           -dp Annotate the assembler output with a comment indicating which pattern and alternative is used.  The length of each instruction is also printed.

           -dP Dump the RTL in the assembler output as a comment before each instruction.  Also turns on -dp annotation.

           -dx Just generate RTL for a function instead of compiling it.  Usually used with -fdump-rtl-expand.

       -fdump-noaddr
           When doing debugging dumps, suppress address output.  This makes it more feasible to use diff on debugging dumps for compiler invocations with different compiler binaries and/or different text / bss / data / heap / stack / dso start locations.

       -fdump-unnumbered
           When doing debugging dumps, suppress instruction numbers and address output.  This makes it more feasible to use diff on debugging dumps for compiler invocations with different options, in particular with and without -g.

       -fdump-unnumbered-links
           When doing debugging dumps (see -d option above), suppress instruction numbers for the links to the previous and next instructions in a sequence.

       -fdump-translation-unit (C++ only)
       -fdump-translation-unit-options (C++ only)
           Dump a representation of the tree structure for the entire translation unit to a file.  The file name is made by appending .tu to the source file name, and the file is created in the same directory as the output file.  If the -options form is used, options controls the details of the dump as described for the -fdump-tree options.

       -fdump-class-hierarchy (C++ only)
       -fdump-class-hierarchy-options (C++ only)
           Dump a representation of each class's hierarchy and virtual function table layout to a file.  The file name is made by appending .class to the source file name, and the file is created in the same directory as the output file.  If the -options form is used, options controls the details of the dump as described for the -fdump-tree options.

       -fdump-ipa-switch
           Control the dumping at various stages of inter-procedural analysis language tree to a file.  The file name is generated by appending a switch specific suffix to the source file name, and the file is created in the same directory as the output file.  The following dumps are possible:

           all Enables all inter-procedural analysis dumps.

           cgraph
               Dumps information about call-graph optimization, unused function removal, and inlining decisions.

           inline
               Dump after function inlining.

       -fdump-passes
           Dump the list of optimization passes that are turned on and off by the current command-line options.

       -fdump-statistics-option
           Enable and control dumping of pass statistics in a separate file.  The file name is generated by appending a suffix ending in .statistics to the source file name, and the file is created in the same directory as the output file.  If the -option form is used, -stats causes counters to be summed over the whole compilation unit while -details dumps every event as the passes generate them.  The default with no option is to sum counters for each function compiled.

       -fdump-tree-switch
       -fdump-tree-switch-options
       -fdump-tree-switch-options=filename
           Control the dumping at various stages of processing the intermediate language tree to a file.  The file name is generated by appending a switch-specific suffix to the source file name, and the file is created in the same directory as the output file. In case of =filename option, the dump is output on the given file instead of the auto named dump files.  If the -options form is used, options is a list of - separated options which control the details of the dump.  Not all options are applicable to all dumps; those that are not meaningful are ignored.  The following options are available

           address
               Print the address of each node.  Usually this is not meaningful as it changes according to the environment and source file.  Its primary use is for tying up a dump file with a debug environment.

           asmname
               If "DECL_ASSEMBLER_NAME" has been set for a given decl, use that in the dump instead of "DECL_NAME".  Its primary use is ease of use working backward from mangled names in the assembly file.

           slim
               When dumping front-end intermediate representations, inhibit dumping of members of a scope or body of a function merely because that scope has been reached.  Only dump such items when they are directly reachable by some other path.

               When dumping pretty-printed trees, this option inhibits dumping the bodies of control structures.

               When dumping RTL, print the RTL in slim (condensed) form instead of the default LISP-like representation.

           raw Print a raw representation of the tree.  By default, trees are pretty-printed into a C-like representation.

           details
               Enable more detailed dumps (not honored by every dump option). Also include information from the optimization passes.

           stats
               Enable dumping various statistics about the pass (not honored by every dump option).

           blocks
               Enable showing basic block boundaries (disabled in raw dumps).

           graph
               For each of the other indicated dump files (-fdump-rtl-pass), dump a representation of the control flow graph suitable for viewing with GraphViz to file.passid.pass.dot.  Each function in the file is pretty-printed as a subgraph, so that GraphViz can render them all in a single plot.

               This option currently only works for RTL dumps, and the RTL is always dumped in slim form.

           vops
               Enable showing virtual operands for every statement.

           lineno
               Enable showing line numbers for statements.

           uid Enable showing the unique ID ("DECL_UID") for each variable.

           verbose
               Enable showing the tree dump for each statement.

           eh  Enable showing the EH region number holding each statement.

           scev
               Enable showing scalar evolution analysis details.

           optimized
               Enable showing optimization information (only available in certain passes).

           missed
               Enable showing missed optimization information (only available in certain passes).

           notes
               Enable other detailed optimization information (only available in certain passes).

           =filename
               Instead of an auto named dump file, output into the given file name. The file names stdout and stderr are treated specially and are considered already open standard streams. For example,

                       gcc -O2 -ftree-vectorize -fdump-tree-vect-blocks=foo.dump
                            -fdump-tree-pre=stderr file.c

               outputs vectorizer dump into foo.dump, while the PRE dump is output on to stderr. If two conflicting dump filenames are given for the same pass, then the latter option overrides the earlier one.

           all Turn on all options, except raw, slim, verbose and lineno.

           optall
               Turn on all optimization options, i.e., optimized, missed, and note.

           The following tree dumps are possible:

           original
               Dump before any tree based optimization, to file.original.

           optimized
               Dump after all tree based optimization, to file.optimized.

           gimple
               Dump each function before and after the gimplification pass to a file.  The file name is made by appending .gimple to the source file name.

           cfg Dump the control flow graph of each function to a file.  The file name is made by appending .cfg to the source file name.

           ch  Dump each function after copying loop headers.  The file name is made by appending .ch to the source file name.

           ssa Dump SSA related information to a file.  The file name is made by appending .ssa to the source file name.

           alias
               Dump aliasing information for each function.  The file name is made by appending .alias to the source file name.

           ccp Dump each function after CCP.  The file name is made by appending .ccp to the source file name.

           storeccp
               Dump each function after STORE-CCP.  The file name is made by appending .storeccp to the source file name.

           pre Dump trees after partial redundancy elimination.  The file name is made by appending .pre to the source file name.

           fre Dump trees after full redundancy elimination.  The file name is made by appending .fre to the source file name.

           copyprop
               Dump trees after copy propagation.  The file name is made by appending .copyprop to the source file name.

           store_copyprop
               Dump trees after store copy-propagation.  The file name is made by appending .store_copyprop to the source file name.

           dce Dump each function after dead code elimination.  The file name is made by appending .dce to the source file name.

           sra Dump each function after performing scalar replacement of aggregates.  The file name is made by appending .sra to the source file name.

           sink
               Dump each function after performing code sinking.  The file name is made by appending .sink to the source file name.

           dom Dump each function after applying dominator tree optimizations.  The file name is made by appending .dom to the source file name.

           dse Dump each function after applying dead store elimination.  The file name is made by appending .dse to the source file name.

           phiopt
               Dump each function after optimizing PHI nodes into straightline code.  The file name is made by appending .phiopt to the source file name.

           forwprop
               Dump each function after forward propagating single use variables.  The file name is made by appending .forwprop to the source file name.

           copyrename
               Dump each function after applying the copy rename optimization.  The file name is made by appending .copyrename to the source file name.

           nrv Dump each function after applying the named return value optimization on generic trees.  The file name is made by appending .nrv to the source file name.

           vect
               Dump each function after applying vectorization of loops.  The file name is made by appending .vect to the source file name.

           slp Dump each function after applying vectorization of basic blocks.  The file name is made by appending .slp to the source file name.

           vrp Dump each function after Value Range Propagation (VRP).  The file name is made by appending .vrp to the source file name.

           all Enable all the available tree dumps with the flags provided in this option.

       -fopt-info
       -fopt-info-options
       -fopt-info-options=filename
           Controls optimization dumps from various optimization passes. If the -options form is used, options is a list of - separated options to select the dump details and optimizations.  If options is not specified, it defaults to optimized for details and optall for optimization groups. If the filename is not specified, it defaults to stderr. Note that the output filename will be overwritten in case of multiple translation units. If a combined output from multiple translation units is desired, stderr should be used instead.

           The options can be divided into two groups, 1) options describing the verbosity of the dump, and 2) options describing which optimizations should be included. The options from both the groups can be freely mixed as they are non-overlapping. However, in case of any conflicts, the latter options override the earlier options on the command line. Though multiple -fopt-info options are accepted, only one of them can have =filename. If other filenames are provided then all but the first one are ignored.

           The dump verbosity has the following options

           optimized
               Print information when an optimization is successfully applied. It is up to a pass to decide which information is relevant. For example, the vectorizer passes print the source location of loops which got successfully vectorized.

           missed
               Print information about missed optimizations. Individual passes control which information to include in the output. For example,

                       gcc -O2 -ftree-vectorize -fopt-info-vec-missed

               will print information about missed optimization opportunities from vectorization passes on stderr.

           note
               Print verbose information about optimizations, such as certain transformations, more detailed messages about decisions etc.

           all Print detailed optimization information. This includes optimized, missed, and note.

           The second set of options describes a group of optimizations and may include one or more of the following.

           ipa Enable dumps from all interprocedural optimizations.

           loop
               Enable dumps from all loop optimizations.

           inline
               Enable dumps from all inlining optimizations.

           vec Enable dumps from all vectorization optimizations.

           optall
               Enable dumps from all optimizations. This is a superset of the optimization groups listed above.

           For example,

                   gcc -O3 -fopt-info-missed=missed.all

           outputs missed optimization report from all the passes into missed.all.

           As another example,

                   gcc -O3 -fopt-info-inline-optimized-missed=inline.txt

           will output information about missed optimizations as well as optimized locations from all the inlining passes into inline.txt.

           If the filename is provided, then the dumps from all the applicable optimizations are concatenated into the filename.  Otherwise the dump is output onto stderr. If options is omitted, it defaults to all-optall, which means dump all available optimization info from all the passes. In the following example, all optimization info is output on to stderr.

                   gcc -O3 -fopt-info

           Note that -fopt-info-vec-missed behaves the same as -fopt-info-missed-vec.

           As another example, consider

                   gcc -fopt-info-vec-missed=vec.miss -fopt-info-loop-optimized=loop.opt

           Here the two output filenames vec.miss and loop.opt are in conflict since only one output file is allowed. In this case, only the first option takes effect and the subsequent options are ignored. Thus only the vec.miss is produced which contains dumps from the vectorizer about missed opportunities.

       -frandom-seed=string
           This option provides a seed that GCC uses in place of random numbers in generating certain symbol names that have to be different in every compiled file.  It is also used to place unique stamps in coverage data files and the object files that produce them.  You can use the -frandom-seed option to produce reproducibly identical object files.

           The string should be different for every file you compile.

       -fsched-verbose=n
           On targets that use instruction scheduling, this option controls the amount of debugging output the scheduler prints.  This information is written to standard error, unless -fdump-rtl-sched1 or -fdump-rtl-sched2 is specified, in which case it is output to the usual dump listing file, .sched1 or .sched2 respectively.  However for n greater than nine, the output is always printed to standard error.

           For n greater than zero, -fsched-verbose outputs the same information as -fdump-rtl-sched1 and -fdump-rtl-sched2.  For n greater than one, it also output basic block probabilities, detailed ready list information and unit/insn info.  For n greater than two, it includes RTL at abort point, control-flow and regions info.  And for n over four, -fsched-verbose also includes dependence info.

       -save-temps
       -save-temps=cwd
           Store the usual "temporary" intermediate files permanently; place them in the current directory and name them based on the source file.  Thus, compiling foo.c with -c -save-temps produces files foo.i and foo.s, as well as foo.o.  This creates a preprocessed foo.i output file even though the compiler now normally uses an integrated preprocessor.

           When used in combination with the -x command-line option, -save-temps is sensible enough to avoid over writing an input source file with the same extension as an intermediate file.  The corresponding intermediate file may be obtained by renaming the source file before using -save-temps.

           If you invoke GCC in parallel, compiling several different source files that share a common base name in different subdirectories or the same source file compiled for multiple output destinations, it is likely that the different parallel compilers will interfere with each other, and overwrite the temporary files.  For instance:

                   gcc -save-temps -o outdir1/foo.o indir1/foo.c&
                   gcc -save-temps -o outdir2/foo.o indir2/foo.c&

           may result in foo.i and foo.o being written to simultaneously by both compilers.

       -save-temps=obj
           Store the usual "temporary" intermediate files permanently.  If the -o option is used, the temporary files are based on the object file.  If the -o option is not used, the -save-temps=obj switch behaves like -save-temps.

           For example:

                   gcc -save-temps=obj -c foo.c
                   gcc -save-temps=obj -c bar.c -o dir/xbar.o
                   gcc -save-temps=obj foobar.c -o dir2/yfoobar

           creates foo.i, foo.s, dir/xbar.i, dir/xbar.s, dir2/yfoobar.i, dir2/yfoobar.s, and dir2/yfoobar.o.

       -time[=file]
           Report the CPU time taken by each subprocess in the compilation sequence.  For C source files, this is the compiler proper and assembler (plus the linker if linking is done).

           Without the specification of an output file, the output looks like this:

                   # cc1 0.12 0.01
                   # as 0.00 0.01

           The first number on each line is the "user time", that is time spent executing the program itself.  The second number is "system time", time spent executing operating system routines on behalf of the program.  Both numbers are in seconds.

           With the specification of an output file, the output is appended to the named file, and it looks like this:

                   0.12 0.01 cc1 <options>
                   0.00 0.01 as <options>

           The "user time" and the "system time" are moved before the program name, and the options passed to the program are displayed, so that one can later tell what file was being compiled, and with which options.

       -fvar-tracking
           Run variable tracking pass.  It computes where variables are stored at each position in code.  Better debugging information is then generated (if the debugging information format supports this information).

           It is enabled by default when compiling with optimization (-Os, -O, -O2, ...), debugging information (-g) and the debug info format supports it.

       -fvar-tracking-assignments
           Annotate assignments to user variables early in the compilation and attempt to carry the annotations over throughout the compilation all the way to the end, in an attempt to improve debug information while optimizing.  Use of -gdwarf-4 is recommended along with it.

           It can be enabled even if var-tracking is disabled, in which case annotations are created and maintained, but discarded at the end.

       -fvar-tracking-assignments-toggle
           Toggle -fvar-tracking-assignments, in the same way that -gtoggle toggles -g.

       -print-file-name=library
           Print the full absolute name of the library file library that would be used when linking---and don't do anything else.  With this option, GCC does not compile or link anything; it just prints the file name.

       -print-multi-directory
           Print the directory name corresponding to the multilib selected by any other switches present in the command line.  This directory is supposed to exist in GCC_EXEC_PREFIX.

       -print-multi-lib
           Print the mapping from multilib directory names to compiler switches that enable them.  The directory name is separated from the switches by ;, and each switch starts with an @ instead of the -, without spaces between multiple switches.  This is supposed to ease shell processing.

       -print-multi-os-directory
           Print the path to OS libraries for the selected multilib, relative to some lib subdirectory.  If OS libraries are present in the lib subdirectory and no multilibs are used, this is usually just ., if OS libraries are present in libsuffix sibling directories this prints e.g. ../lib64, ../lib or ../lib32, or if OS libraries are present in lib/subdir subdirectories it prints e.g. amd64, sparcv9 or ev6.

       -print-multiarch
           Print the path to OS libraries for the selected multiarch, relative to some lib subdirectory.

       -print-prog-name=program
           Like -print-file-name, but searches for a program such as cpp.

       -print-libgcc-file-name
           Same as -print-file-name=libgcc.a.

           This is useful when you use -nostdlib or -nodefaultlibs but you do want to link with libgcc.a.  You can do:

                   gcc -nostdlib <files>... `gcc -print-libgcc-file-name`

       -print-search-dirs
           Print the name of the configured installation directory and a list of program and library directories gcc searches---and don't do anything else.

           This is useful when gcc prints the error message installation problem, cannot exec cpp0: No such file or directory.  To resolve this you either need to put cpp0 and the other compiler components where gcc expects to find them, or you can set the environment variable GCC_EXEC_PREFIX to the directory where you installed them.  Don't forget the trailing /.

       -print-sysroot
           Print the target sysroot directory that is used during compilation.  This is the target sysroot specified either at configure time or using the --sysroot option, possibly with an extra suffix that depends on compilation options.  If no target sysroot is specified, the option prints nothing.

       -print-sysroot-headers-suffix
           Print the suffix added to the target sysroot when searching for headers, or give an error if the compiler is not configured with such a suffix---and don't do anything else.

       -dumpmachine
           Print the compiler's target machine (for example, i686-pc-linux-gnu)---and don't do anything else.

       -dumpversion
           Print the compiler version (for example, 3.0)---and don't do anything else.

       -dumpspecs
           Print the compiler's built-in specs---and don't do anything else.  (This is used when GCC itself is being built.)

       -fno-eliminate-unused-debug-types
           Normally, when producing DWARF 2 output, GCC avoids producing debug symbol output for types that are nowhere used in the source file being compiled.  Sometimes it is useful to have GCC emit debugging information for all types declared in a compilation unit, regardless of whether or not they are actually used in that compilation unit, for example if, in the debugger, you want to cast a value to a type that is not actually used in your program (but is declared).  More often, however, this results in a significant amount of wasted space.

   Options That Control Optimization
       These options control various sorts of optimizations.

       Without any optimization option, the compiler's goal is to reduce the cost of compilation and to make debugging produce the expected results.  Statements are independent: if you stop the program with a breakpoint between statements, you can then assign a new value to any variable or change the program counter to any other statement in the function and get exactly the results you expect from the source code.

       Turning on optimization flags makes the compiler attempt to improve the performance and/or code size at the expense of compilation time and possibly the ability to debug the program.

       The compiler performs optimization based on the knowledge it has of the program.  Compiling multiple files at once to a single output file mode allows the compiler to use information gained from all of the files when compiling each of them.

       Not all optimizations are controlled directly by a flag.  Only optimizations that have a flag are listed in this section.

       Most optimizations are only enabled if an -O level is set on the command line.  Otherwise they are disabled, even if individual optimization flags are specified.

       Depending on the target and how GCC was configured, a slightly different set of optimizations may be enabled at each -O level than those listed here.  You can invoke GCC with -Q --help=optimizers to find out the exact set of optimizations that are enabled at each level.

       -O
       -O1 Optimize.  Optimizing compilation takes somewhat more time, and a lot more memory for a large function.

           With -O, the compiler tries to reduce code size and execution time, without performing any optimizations that take a great deal of compilation time.

           -O turns on the following optimization flags:

           -fauto-inc-dec -fcompare-elim -fcprop-registers -fdce -fdefer-pop -fdelayed-branch -fdse -fguess-branch-probability -fif-conversion2 -fif-conversion -fipa-pure-const -fipa-profile -fipa-reference -fmerge-constants -fsplit-wide-types -ftree-bit-ccp -ftree-builtin-call-dce -ftree-ccp -ftree-ch -ftree-copyrename -ftree-dce -ftree-dominator-opts -ftree-dse -ftree-forwprop -ftree-fre -ftree-phiprop -ftree-slsr -ftree-sra -ftree-pta -ftree-ter -funit-at-a-time

           -O also turns on -fomit-frame-pointer on machines where doing so does not interfere with debugging.

       -O2 Optimize even more.  GCC performs nearly all supported optimizations that do not involve a space-speed tradeoff.  As compared to -O, this option increases both compilation time and the performance of the generated code.

           -O2 turns on all optimization flags specified by -O.  It also turns on the following optimization flags: -fthread-jumps -falign-functions  -falign-jumps -falign-loops  -falign-labels -fcaller-saves -fcrossjumping -fcse-follow-jumps  -fcse-skip-blocks -fdelete-null-pointer-checks -fdevirtualize -fdevirtualize-speculatively -fexpensive-optimizations -fgcse  -fgcse-lm -fhoist-adjacent-loads -finline-small-functions -findirect-inlining -fipa-sra -fisolate-erroneous-paths-dereference -foptimize-sibling-calls -fpartial-inlining -fpeephole2 -freorder-blocks  -freorder-functions -frerun-cse-after-loop -fsched-interblock  -fsched-spec -fschedule-insns  -fschedule-insns2 -fstrict-aliasing -fstrict-overflow -ftree-switch-conversion -ftree-tail-merge -ftree-pre -ftree-vrp

           Please note the warning under -fgcse about invoking -O2 on programs that use computed gotos.

           NOTE: In Ubuntu 8.10 and later versions, -D_FORTIFY_SOURCE=2 is set by default, and is activated when -O is set to 2 or higher.  This enables additional compile-time and run-time checks for several libc functions.  To disable, specify either -U_FORTIFY_SOURCE or -D_FORTIFY_SOURCE=0.

       -O3 Optimize yet more.  -O3 turns on all optimizations specified by -O2 and also turns on the -finline-functions, -funswitch-loops, -fpredictive-commoning, -fgcse-after-reload, -ftree-loop-vectorize, -ftree-slp-vectorize, -fvect-cost-model, -ftree-partial-pre and -fipa-cp-clone options.

       -O0 Reduce compilation time and make debugging produce the expected results.  This is the default.

       -Os Optimize for size.  -Os enables all -O2 optimizations that do not typically increase code size.  It also performs further optimizations designed to reduce code size.

           -Os disables the following optimization flags: -falign-functions  -falign-jumps  -falign-loops -falign-labels  -freorder-blocks  -freorder-blocks-and-partition -fprefetch-loop-arrays

       -Ofast
           Disregard strict standards compliance.  -Ofast enables all -O3 optimizations.  It also enables optimizations that are not valid for all standard-compliant programs.  It turns on -ffast-math and the Fortran-specific -fno-protect-parens and -fstack-arrays.

       -Og Optimize debugging experience.  -Og enables optimizations that do not interfere with debugging. It should be the optimization level of choice for the standard edit-compile-debug cycle, offering a reasonable level of optimization while maintaining fast compilation and a good debugging experience.

           If you use multiple -O options, with or without level numbers, the last such option is the one that is effective.

       Options of the form -fflag specify machine-independent flags.  Most flags have both positive and negative forms; the negative form of -ffoo is -fno-foo.  In the table below, only one of the forms is listed---the one you typically use.  You can figure out the other form by either removing no- or adding it.

       The following options control specific optimizations.  They are either activated by -O options or are related to ones that are.  You can use the following flags in the rare cases when "fine-tuning" of optimizations to be performed is desired.

       -fno-defer-pop
           Always pop the arguments to each function call as soon as that function returns.  For machines that must pop arguments after a function call, the compiler normally lets arguments accumulate on the stack for several function calls and pops them all at once.

           Disabled at levels -O, -O2, -O3, -Os.

       -fforward-propagate
           Perform a forward propagation pass on RTL.  The pass tries to combine two instructions and checks if the result can be simplified.  If loop unrolling is active, two passes are performed and the second is scheduled after loop unrolling.

           This option is enabled by default at optimization levels -O, -O2, -O3, -Os.

       -ffp-contract=style
           -ffp-contract=off disables floating-point expression contraction.  -ffp-contract=fast enables floating-point expression contraction such as forming of fused multiply-add operations if the target has native support for them.  -ffp-contract=on enables floating-point expression contraction if allowed by the language standard.  This is currently not implemented and treated equal to -ffp-contract=off.

           The default is -ffp-contract=fast.

       -fomit-frame-pointer
           Don't keep the frame pointer in a register for functions that don't need one.  This avoids the instructions to save, set up and restore frame pointers; it also makes an extra register available in many functions.  It also makes debugging impossible on some machines.

           On some machines, such as the VAX, this flag has no effect, because the standard calling sequence automatically handles the frame pointer and nothing is saved by pretending it doesn't exist.  The machine-description macro "FRAME_POINTER_REQUIRED" controls whether a target machine supports this flag.

           Starting with GCC version 4.6, the default setting (when not optimizing for size) for 32-bit GNU/Linux x86 and 32-bit Darwin x86 targets has been changed to -fomit-frame-pointer.  The default can be reverted to -fno-omit-frame-pointer by configuring GCC with the --enable-frame-pointer configure option.

           Enabled at levels -O, -O2, -O3, -Os.

       -foptimize-sibling-calls
           Optimize sibling and tail recursive calls.

           Enabled at levels -O2, -O3, -Os.

       -fno-inline
           Do not expand any functions inline apart from those marked with the "always_inline" attribute.  This is the default when not optimizing.

           Single functions can be exempted from inlining by marking them with the "noinline" attribute.

       -finline-small-functions
           Integrate functions into their callers when their body is smaller than expected function call code (so overall size of program gets smaller).  The compiler heuristically decides which functions are simple enough to be worth integrating in this way.  This inlining applies to all functions, even those not declared inline.

           Enabled at level -O2.

       -findirect-inlining
           Inline also indirect calls that are discovered to be known at compile time thanks to previous inlining.  This option has any effect only when inlining itself is turned on by the -finline-functions or -finline-small-functions options.

           Enabled at level -O2.

       -finline-functions
           Consider all functions for inlining, even if they are not declared inline.  The compiler heuristically decides which functions are worth integrating in this way.

           If all calls to a given function are integrated, and the function is declared "static", then the function is normally not output as assembler code in its own right.

           Enabled at level -O3.

       -finline-functions-called-once
           Consider all "static" functions called once for inlining into their caller even if they are not marked "inline".  If a call to a given function is integrated, then the function is not output as assembler code in its own right.

           Enabled at levels -O1, -O2, -O3 and -Os.

       -fearly-inlining
           Inline functions marked by "always_inline" and functions whose body seems smaller than the function call overhead early before doing -fprofile-generate instrumentation and real inlining pass.  Doing so makes profiling significantly cheaper and usually inlining faster on programs having large chains of nested wrapper functions.

           Enabled by default.

       -fipa-sra
           Perform interprocedural scalar replacement of aggregates, removal of unused parameters and replacement of parameters passed by reference by parameters passed by value.

           Enabled at levels -O2, -O3 and -Os.

       -finline-limit=n
           By default, GCC limits the size of functions that can be inlined.  This flag allows coarse control of this limit.  n is the size of functions that can be inlined in number of pseudo instructions.

           Inlining is actually controlled by a number of parameters, which may be specified individually by using --param name=value.  The -finline-limit=n option sets some of these parameters as follows:

           max-inline-insns-single
               is set to n/2.

           max-inline-insns-auto
               is set to n/2.

           See below for a documentation of the individual parameters controlling inlining and for the defaults of these parameters.

           Note: there may be no value to -finline-limit that results in default behavior.

           Note: pseudo instruction represents, in this particular context, an abstract measurement of function's size.  In no way does it represent a count of assembly instructions and as such its exact meaning might change from one release to an another.

       -fno-keep-inline-dllexport
           This is a more fine-grained version of -fkeep-inline-functions, which applies only to functions that are declared using the "dllexport" attribute or declspec

       -fkeep-inline-functions
           In C, emit "static" functions that are declared "inline" into the object file, even if the function has been inlined into all of its callers.  This switch does not affect functions using the "extern inline" extension in GNU C90.  In C++, emit any and all inline functions into the object file.

       -fkeep-static-consts
           Emit variables declared "static const" when optimization isn't turned on, even if the variables aren't referenced.

           GCC enables this option by default.  If you want to force the compiler to check if a variable is referenced, regardless of whether or not optimization is turned on, use the -fno-keep-static-consts option.

       -fmerge-constants
           Attempt to merge identical constants (string constants and floating-point constants) across compilation units.

           This option is the default for optimized compilation if the assembler and linker support it.  Use -fno-merge-constants to inhibit this behavior.

           Enabled at levels -O, -O2, -O3, -Os.

       -fmerge-all-constants
           Attempt to merge identical constants and identical variables.

           This option implies -fmerge-constants.  In addition to -fmerge-constants this considers e.g. even constant initialized arrays or initialized constant variables with integral or floating-point types.  Languages like C or C++ require each variable, including multiple instances of the same variable in recursive calls, to have distinct locations, so using this option results in non-conforming behavior.

       -fmodulo-sched
           Perform swing modulo scheduling immediately before the first scheduling pass.  This pass looks at innermost loops and reorders their instructions by overlapping different iterations.

       -fmodulo-sched-allow-regmoves
           Perform more aggressive SMS-based modulo scheduling with register moves allowed.  By setting this flag certain anti-dependences edges are deleted, which triggers the generation of reg-moves based on the life-range analysis.  This option is effective only with -fmodulo-sched enabled.

       -fno-branch-count-reg
           Do not use "decrement and branch" instructions on a count register, but instead generate a sequence of instructions that decrement a register, compare it against zero, then branch based upon the result.  This option is only meaningful on architectures that support such instructions, which include x86, PowerPC, IA-64 and S/390.

           The default is -fbranch-count-reg.

       -fno-function-cse
           Do not put function addresses in registers; make each instruction that calls a constant function contain the function's address explicitly.

           This option results in less efficient code, but some strange hacks that alter the assembler output may be confused by the optimizations performed when this option is not used.

           The default is -ffunction-cse

       -fno-zero-initialized-in-bss
           If the target supports a BSS section, GCC by default puts variables that are initialized to zero into BSS.  This can save space in the resulting code.

           This option turns off this behavior because some programs explicitly rely on variables going to the data section---e.g., so that the resulting executable can find the beginning of that section and/or make assumptions based on that.

           The default is -fzero-initialized-in-bss.

       -fthread-jumps
           Perform optimizations that check to see if a jump branches to a location where another comparison subsumed by the first is found.  If so, the first branch is redirected to either the destination of the second branch or a point immediately following it, depending on whether the condition is known to be true or false.

           Enabled at levels -O2, -O3, -Os.

       -fsplit-wide-types
           When using a type that occupies multiple registers, such as "long long" on a 32-bit system, split the registers apart and allocate them independently.  This normally generates better code for those types, but may make debugging more difficult.

           Enabled at levels -O, -O2, -O3, -Os.

       -fcse-follow-jumps
           In common subexpression elimination (CSE), scan through jump instructions when the target of the jump is not reached by any other path.  For example, when CSE encounters an "if" statement with an "else" clause, CSE follows the jump when the condition tested is false.

           Enabled at levels -O2, -O3, -Os.

       -fcse-skip-blocks
           This is similar to -fcse-follow-jumps, but causes CSE to follow jumps that conditionally skip over blocks.  When CSE encounters a simple "if" statement with no else clause, -fcse-skip-blocks causes CSE to follow the jump around the body of the "if".

           Enabled at levels -O2, -O3, -Os.

       -frerun-cse-after-loop
           Re-run common subexpression elimination after loop optimizations are performed.

           Enabled at levels -O2, -O3, -Os.

       -fgcse
           Perform a global common subexpression elimination pass.  This pass also performs global constant and copy propagation.

           Note: When compiling a program using computed gotos, a GCC extension, you may get better run-time performance if you disable the global common subexpression elimination pass by adding -fno-gcse to the command line.

           Enabled at levels -O2, -O3, -Os.

       -fgcse-lm
           When -fgcse-lm is enabled, global common subexpression elimination attempts to move loads that are only killed by stores into themselves.  This allows a loop containing a load/store sequence to be changed to a load outside the loop, and a copy/store within the loop.

           Enabled by default when -fgcse is enabled.

       -fgcse-sm
           When -fgcse-sm is enabled, a store motion pass is run after global common subexpression elimination.  This pass attempts to move stores out of loops.  When used in conjunction with -fgcse-lm, loops containing a load/store sequence can be changed to a load before the loop and a store after the loop.

           Not enabled at any optimization level.

       -fgcse-las
           When -fgcse-las is enabled, the global common subexpression elimination pass eliminates redundant loads that come after stores to the same memory location (both partial and full redundancies).

           Not enabled at any optimization level.

       -fgcse-after-reload
           When -fgcse-after-reload is enabled, a redundant load elimination pass is performed after reload.  The purpose of this pass is to clean up redundant spilling.

       -faggressive-loop-optimizations
           This option tells the loop optimizer to use language constraints to derive bounds for the number of iterations of a loop.  This assumes that loop code does not invoke undefined behavior by for example causing signed integer overflows or out-of-bound array accesses.  The bounds for the number of iterations of a loop are used to guide loop unrolling and peeling and loop exit test optimizations.  This option is enabled by default.

       -funsafe-loop-optimizations
           This option tells the loop optimizer to assume that loop indices do not overflow, and that loops with nontrivial exit condition are not infinite.  This enables a wider range of loop optimizations even if the loop optimizer itself cannot prove that these assumptions are valid.  If you use -Wunsafe-loop-optimizations, the compiler warns you if it finds this kind of loop.

       -fcrossjumping
           Perform cross-jumping transformation.  This transformation unifies equivalent code and saves code size.  The resulting code may or may not perform better than without cross-jumping.

           Enabled at levels -O2, -O3, -Os.

       -fauto-inc-dec
           Combine increments or decrements of addresses with memory accesses.  This pass is always skipped on architectures that do not have instructions to support this.  Enabled by default at -O and higher on architectures that support this.

       -fdce
           Perform dead code elimination (DCE) on RTL.  Enabled by default at -O and higher.

       -fdse
           Perform dead store elimination (DSE) on RTL.  Enabled by default at -O and higher.

       -fif-conversion
           Attempt to transform conditional jumps into branch-less equivalents.  This includes use of conditional moves, min, max, set flags and abs instructions, and some tricks doable by standard arithmetics.  The use of conditional execution on chips where it is available is controlled by "if-conversion2".

           Enabled at levels -O, -O2, -O3, -Os.

       -fif-conversion2
           Use conditional execution (where available) to transform conditional jumps into branch-less equivalents.

           Enabled at levels -O, -O2, -O3, -Os.

       -fdeclone-ctor-dtor
           The C++ ABI requires multiple entry points for constructors and destructors: one for a base subobject, one for a complete object, and one for a virtual destructor that calls operator delete afterwards.  For a hierarchy with virtual bases, the base and complete variants are clones, which means two copies of the function.  With this option, the base and complete variants are changed to be thunks that call a common implementation.

           Enabled by -Os.

       -fdelete-null-pointer-checks
           Assume that programs cannot safely dereference null pointers, and that no code or data element resides there.  This enables simple constant folding optimizations at all optimization levels.  In addition, other optimization passes in GCC use this flag to control global dataflow analyses that eliminate useless checks for null pointers; these assume that if a pointer is checked after it has already been dereferenced, it cannot be null.

           Note however that in some environments this assumption is not true.  Use -fno-delete-null-pointer-checks to disable this optimization for programs that depend on that behavior.

           Some targets, especially embedded ones, disable this option at all levels.  Otherwise it is enabled at all levels: -O0, -O1, -O2, -O3, -Os.  Passes that use the information are enabled independently at different optimization levels.

       -fdevirtualize
           Attempt to convert calls to virtual functions to direct calls.  This is done both within a procedure and interprocedurally as part of indirect inlining ("-findirect-inlining") and interprocedural constant propagation (-fipa-cp).  Enabled at levels -O2, -O3, -Os.

       -fdevirtualize-speculatively
           Attempt to convert calls to virtual functions to speculative direct calls.  Based on the analysis of the type inheritance graph, determine for a given call the set of likely targets. If the set is small, preferably of size 1, change the call into an conditional deciding on direct and indirect call.  The speculative calls enable more optimizations, such as inlining.  When they seem useless after further optimization, they are converted back into original form.

       -fexpensive-optimizations
           Perform a number of minor optimizations that are relatively expensive.

           Enabled at levels -O2, -O3, -Os.

       -free
           Attempt to remove redundant extension instructions.  This is especially helpful for the x86-64 architecture, which implicitly zero-extends in 64-bit registers after writing to their lower 32-bit half.

           Enabled for Alpha, AArch64 and x86 at levels -O2, -O3, -Os.

       -flive-range-shrinkage
           Attempt to decrease register pressure through register live range shrinkage.  This is helpful for fast processors with small or moderate size register sets.

       -fira-algorithm=algorithm
           Use the specified coloring algorithm for the integrated register allocator.  The algorithm argument can be priority, which specifies Chow's priority coloring, or CB, which specifies Chaitin-Briggs coloring.  Chaitin-Briggs coloring is not implemented for all architectures, but for those targets that do support it, it is the default because it generates better code.

       -fira-region=region
           Use specified regions for the integrated register allocator.  The region argument should be one of the following:

           all Use all loops as register allocation regions.  This can give the best results for machines with a small and/or irregular register set.

           mixed
               Use all loops except for loops with small register pressure as the regions.  This value usually gives the best results in most cases and for most architectures, and is enabled by default when compiling with optimization for speed (-O, -O2, ...).

           one Use all functions as a single region.  This typically results in the smallest code size, and is enabled by default for -Os or -O0.

       -fira-hoist-pressure
           Use IRA to evaluate register pressure in the code hoisting pass for decisions to hoist expressions.  This option usually results in smaller code, but it can slow the compiler down.

           This option is enabled at level -Os for all targets.

       -fira-loop-pressure
           Use IRA to evaluate register pressure in loops for decisions to move loop invariants.  This option usually results in generation of faster and smaller code on machines with large register files (>= 32 registers), but it can slow the compiler down.

           This option is enabled at level -O3 for some targets.

       -fno-ira-share-save-slots
           Disable sharing of stack slots used for saving call-used hard registers living through a call.  Each hard register gets a separate stack slot, and as a result function stack frames are larger.

       -fno-ira-share-spill-slots
           Disable sharing of stack slots allocated for pseudo-registers.  Each pseudo-register that does not get a hard register gets a separate stack slot, and as a result function stack frames are larger.

       -fira-verbose=n
           Control the verbosity of the dump file for the integrated register allocator.  The default value is 5.  If the value n is greater or equal to 10, the dump output is sent to stderr using the same format as n minus 10.

       -fdelayed-branch
           If supported for the target machine, attempt to reorder instructions to exploit instruction slots available after delayed branch instructions.

           Enabled at levels -O, -O2, -O3, -Os.

       -fschedule-insns
           If supported for the target machine, attempt to reorder instructions to eliminate execution stalls due to required data being unavailable.  This helps machines that have slow floating point or memory load instructions by allowing other instructions to be issued until the result of the load or floating-point instruction is required.

           Enabled at levels -O2, -O3.

       -fschedule-insns2
           Similar to -fschedule-insns, but requests an additional pass of instruction scheduling after register allocation has been done.  This is especially useful on machines with a relatively small number of registers and where memory load instructions take more than one cycle.

           Enabled at levels -O2, -O3, -Os.

       -fno-sched-interblock
           Don't schedule instructions across basic blocks.  This is normally enabled by default when scheduling before register allocation, i.e.  with -fschedule-insns or at -O2 or higher.

       -fno-sched-spec
           Don't allow speculative motion of non-load instructions.  This is normally enabled by default when scheduling before register allocation, i.e.  with -fschedule-insns or at -O2 or higher.

       -fsched-pressure
           Enable register pressure sensitive insn scheduling before register allocation.  This only makes sense when scheduling before register allocation is enabled, i.e. with -fschedule-insns or at -O2 or higher.  Usage of this option can improve the generated code and decrease its size by preventing register pressure increase above the number of available hard registers and subsequent spills in register allocation.

       -fsched-spec-load
           Allow speculative motion of some load instructions.  This only makes sense when scheduling before register allocation, i.e. with -fschedule-insns or at -O2 or higher.

       -fsched-spec-load-dangerous
           Allow speculative motion of more load instructions.  This only makes sense when scheduling before register allocation, i.e. with -fschedule-insns or at -O2 or higher.

       -fsched-stalled-insns
       -fsched-stalled-insns=n
           Define how many insns (if any) can be moved prematurely from the queue of stalled insns into the ready list during the second scheduling pass.  -fno-sched-stalled-insns means that no insns are moved prematurely, -fsched-stalled-insns=0 means there is no limit on how many queued insns can be moved prematurely.  -fsched-stalled-insns without a value is equivalent to -fsched-stalled-insns=1.

       -fsched-stalled-insns-dep
       -fsched-stalled-insns-dep=n
           Define how many insn groups (cycles) are examined for a dependency on a stalled insn that is a candidate for premature removal from the queue of stalled insns.  This has an effect only during the second scheduling pass, and only if -fsched-stalled-insns is used.  -fno-sched-stalled-insns-dep is equivalent to -fsched-stalled-insns-dep=0.  -fsched-stalled-insns-dep without a value is equivalent to -fsched-stalled-insns-dep=1.

       -fsched2-use-superblocks
           When scheduling after register allocation, use superblock scheduling.  This allows motion across basic block boundaries, resulting in faster schedules.  This option is experimental, as not all machine descriptions used by GCC model the CPU closely enough to avoid unreliable results from the algorithm.

           This only makes sense when scheduling after register allocation, i.e. with -fschedule-insns2 or at -O2 or higher.

       -fsched-group-heuristic
           Enable the group heuristic in the scheduler.  This heuristic favors the instruction that belongs to a schedule group.  This is enabled by default when scheduling is enabled, i.e. with -fschedule-insns or -fschedule-insns2 or at -O2 or higher.

       -fsched-critical-path-heuristic
           Enable the critical-path heuristic in the scheduler.  This heuristic favors instructions on the critical path.  This is enabled by default when scheduling is enabled, i.e. with -fschedule-insns or -fschedule-insns2 or at -O2 or higher.

       -fsched-spec-insn-heuristic
           Enable the speculative instruction heuristic in the scheduler.  This heuristic favors speculative instructions with greater dependency weakness.  This is enabled by default when scheduling is enabled, i.e.  with -fschedule-insns or -fschedule-insns2 or at -O2 or higher.

       -fsched-rank-heuristic
           Enable the rank heuristic in the scheduler.  This heuristic favors the instruction belonging to a basic block with greater size or frequency.  This is enabled by default when scheduling is enabled, i.e.  with -fschedule-insns or -fschedule-insns2 or at -O2 or higher.

       -fsched-last-insn-heuristic
           Enable the last-instruction heuristic in the scheduler.  This heuristic favors the instruction that is less dependent on the last instruction scheduled.  This is enabled by default when scheduling is enabled, i.e. with -fschedule-insns or -fschedule-insns2 or at -O2 or higher.

       -fsched-dep-count-heuristic
           Enable the dependent-count heuristic in the scheduler.  This heuristic favors the instruction that has more instructions depending on it.  This is enabled by default when scheduling is enabled, i.e.  with -fschedule-insns or -fschedule-insns2 or at -O2 or higher.

       -freschedule-modulo-scheduled-loops
           Modulo scheduling is performed before traditional scheduling.  If a loop is modulo scheduled, later scheduling passes may change its schedule.  Use this option to control that behavior.

       -fselective-scheduling
           Schedule instructions using selective scheduling algorithm.  Selective scheduling runs instead of the first scheduler pass.

       -fselective-scheduling2
           Schedule instructions using selective scheduling algorithm.  Selective scheduling runs instead of the second scheduler pass.

       -fsel-sched-pipelining
           Enable software pipelining of innermost loops during selective scheduling.  This option has no effect unless one of -fselective-scheduling or -fselective-scheduling2 is turned on.

       -fsel-sched-pipelining-outer-loops
           When pipelining loops during selective scheduling, also pipeline outer loops.  This option has no effect unless -fsel-sched-pipelining is turned on.

       -fshrink-wrap
           Emit function prologues only before parts of the function that need it, rather than at the top of the function.  This flag is enabled by default at -O and higher.

       -fcaller-saves
           Enable allocation of values to registers that are clobbered by function calls, by emitting extra instructions to save and restore the registers around such calls.  Such allocation is done only when it seems to result in better code.

           This option is always enabled by default on certain machines, usually those which have no call-preserved registers to use instead.

           Enabled at levels -O2, -O3, -Os.

       -fcombine-stack-adjustments
           Tracks stack adjustments (pushes and pops) and stack memory references and then tries to find ways to combine them.

           Enabled by default at -O1 and higher.

       -fconserve-stack
           Attempt to minimize stack usage.  The compiler attempts to use less stack space, even if that makes the program slower.  This option implies setting the large-stack-frame parameter to 100 and the large-stack-frame-growth parameter to 400.

       -ftree-reassoc
           Perform reassociation on trees.  This flag is enabled by default at -O and higher.

       -ftree-pre
           Perform partial redundancy elimination (PRE) on trees.  This flag is enabled by default at -O2 and -O3.

       -ftree-partial-pre
           Make partial redundancy elimination (PRE) more aggressive.  This flag is enabled by default at -O3.

       -ftree-forwprop
           Perform forward propagation on trees.  This flag is enabled by default at -O and higher.

       -ftree-fre
           Perform full redundancy elimination (FRE) on trees.  The difference between FRE and PRE is that FRE only considers expressions that are computed on all paths leading to the redundant computation.  This analysis is faster than PRE, though it exposes fewer redundancies.  This flag is enabled by default at -O and higher.

       -ftree-phiprop
           Perform hoisting of loads from conditional pointers on trees.  This pass is enabled by default at -O and higher.

       -fhoist-adjacent-loads
           Speculatively hoist loads from both branches of an if-then-else if the loads are from adjacent locations in the same structure and the target architecture has a conditional move instruction.  This flag is enabled by default at -O2 and higher.

       -ftree-copy-prop
           Perform copy propagation on trees.  This pass eliminates unnecessary copy operations.  This flag is enabled by default at -O and higher.

       -fipa-pure-const
           Discover which functions are pure or constant.  Enabled by default at -O and higher.

       -fipa-reference
           Discover which static variables do not escape the compilation unit.  Enabled by default at -O and higher.

       -fipa-pta
           Perform interprocedural pointer analysis and interprocedural modification and reference analysis.  This option can cause excessive memory and compile-time usage on large compilation units.  It is not enabled by default at any optimization level.

       -fipa-profile
           Perform interprocedural profile propagation.  The functions called only from cold functions are marked as cold. Also functions executed once (such as "cold", "noreturn", static constructors or destructors) are identified. Cold functions and loop less parts of functions executed once are then optimized for size.  Enabled by default at -O and higher.

       -fipa-cp
           Perform interprocedural constant propagation.  This optimization analyzes the program to determine when values passed to functions are constants and then optimizes accordingly.  This optimization can substantially increase performance if the application has constants passed to functions.  This flag is enabled by default at -O2, -Os and -O3.

       -fipa-cp-clone
           Perform function cloning to make interprocedural constant propagation stronger.  When enabled, interprocedural constant propagation performs function cloning when externally visible function can be called with constant arguments.  Because this optimization can create multiple copies of functions, it may significantly increase code size (see --param ipcp-unit-growth=value).  This flag is enabled by default at -O3.

       -fisolate-erroneous-paths-dereference
           Detect paths which trigger erroneous or undefined behaviour due to dereferencing a NULL pointer.  Isolate those paths from the main control flow and turn the statement with erroneous or undefined behaviour into a trap.

       -fisolate-erroneous-paths-attribute
           Detect paths which trigger erroneous or undefined behaviour due a NULL value being used in a way which is forbidden by a "returns_nonnull" or "nonnull" attribute.  Isolate those paths from the main control flow and turn the statement with erroneous or undefined behaviour into a trap.  This is not currently enabled, but may be enabled by "-O2" in the future.

       -ftree-sink
           Perform forward store motion  on trees.  This flag is enabled by default at -O and higher.

       -ftree-bit-ccp
           Perform sparse conditional bit constant propagation on trees and propagate pointer alignment information.  This pass only operates on local scalar variables and is enabled by default at -O and higher.  It requires that -ftree-ccp is enabled.

       -ftree-ccp
           Perform sparse conditional constant propagation (CCP) on trees.  This pass only operates on local scalar variables and is enabled by default at -O and higher.

       -ftree-switch-conversion
           Perform conversion of simple initializations in a switch to initializations from a scalar array.  This flag is enabled by default at -O2 and higher.

       -ftree-tail-merge
           Look for identical code sequences.  When found, replace one with a jump to the other.  This optimization is known as tail merging or cross jumping.  This flag is enabled by default at -O2 and higher.  The compilation time in this pass can be limited using max-tail-merge-comparisons parameter and max-tail-merge-iterations parameter.

       -ftree-dce
           Perform dead code elimination (DCE) on trees.  This flag is enabled by default at -O and higher.

       -ftree-builtin-call-dce
           Perform conditional dead code elimination (DCE) for calls to built-in functions that may set "errno" but are otherwise side-effect free.  This flag is enabled by default at -O2 and higher if -Os is not also specified.

       -ftree-dominator-opts
           Perform a variety of simple scalar cleanups (constant/copy propagation, redundancy elimination, range propagation and expression simplification) based on a dominator tree traversal.  This also performs jump threading (to reduce jumps to jumps). This flag is enabled by default at -O and higher.

       -ftree-dse
           Perform dead store elimination (DSE) on trees.  A dead store is a store into a memory location that is later overwritten by another store without any intervening loads.  In this case the earlier store can be deleted.  This flag is enabled by default at -O and higher.

       -ftree-ch
           Perform loop header copying on trees.  This is beneficial since it increases effectiveness of code motion optimizations.  It also saves one jump.  This flag is enabled by default at -O and higher.  It is not enabled for -Os, since it usually increases code size.

       -ftree-loop-optimize
           Perform loop optimizations on trees.  This flag is enabled by default at -O and higher.

       -ftree-loop-linear
           Perform loop interchange transformations on tree.  Same as -floop-interchange.  To use this code transformation, GCC has to be configured with --with-ppl and --with-cloog to enable the Graphite loop transformation infrastructure.

       -floop-interchange
           Perform loop interchange transformations on loops.  Interchanging two nested loops switches the inner and outer loops.  For example, given a loop like:

                   DO J = 1, M
                     DO I = 1, N
                       A(J, I) = A(J, I) * C
                     ENDDO
                   ENDDO

           loop interchange transforms the loop as if it were written:

                   DO I = 1, N
                     DO J = 1, M
                       A(J, I) = A(J, I) * C
                     ENDDO
                   ENDDO

           which can be beneficial when "N" is larger than the caches, because in Fortran, the elements of an array are stored in memory contiguously by column, and the original loop iterates over rows, potentially creating at each access a cache miss.  This optimization applies to all the languages supported by GCC and is not limited to Fortran.  To use this code transformation, GCC has to be configured with --with-ppl and --with-cloog to enable the Graphite loop transformation infrastructure.

       -floop-strip-mine
           Perform loop strip mining transformations on loops.  Strip mining splits a loop into two nested loops.  The outer loop has strides equal to the strip size and the inner loop has strides of the original loop within a strip.  The strip length can be changed using the loop-block-tile-size parameter.  For example, given a loop like:

                   DO I = 1, N
                     A(I) = A(I) + C
                   ENDDO

           loop strip mining transforms the loop as if it were written:

                   DO II = 1, N, 51
                     DO I = II, min (II + 50, N)
                       A(I) = A(I) + C
                     ENDDO
                   ENDDO

           This optimization applies to all the languages supported by GCC and is not limited to Fortran.  To use this code transformation, GCC has to be configured with --with-ppl and --with-cloog to enable the Graphite loop transformation infrastructure.

       -floop-block
           Perform loop blocking transformations on loops.  Blocking strip mines each loop in the loop nest such that the memory accesses of the element loops fit inside caches.  The strip length can be changed using the loop-block-tile-size parameter.  For example, given a loop like:

                   DO I = 1, N
                     DO J = 1, M
                       A(J, I) = B(I) + C(J)
                     ENDDO
                   ENDDO

           loop blocking transforms the loop as if it were written:

                   DO II = 1, N, 51
                     DO JJ = 1, M, 51
                       DO I = II, min (II + 50, N)
                         DO J = JJ, min (JJ + 50, M)
                           A(J, I) = B(I) + C(J)
                         ENDDO
                       ENDDO
                     ENDDO
                   ENDDO

           which can be beneficial when "M" is larger than the caches, because the innermost loop iterates over a smaller amount of data which can be kept in the caches.  This optimization applies to all the languages supported by GCC and is not limited to Fortran.  To use this code transformation, GCC has to be configured with --with-ppl and --with-cloog to enable the Graphite loop transformation infrastructure.

       -fgraphite-identity
           Enable the identity transformation for graphite.  For every SCoP we generate the polyhedral representation and transform it back to gimple.  Using -fgraphite-identity we can check the costs or benefits of the GIMPLE -> GRAPHITE -> GIMPLE transformation.  Some minimal optimizations are also performed by the code generator CLooG, like index splitting and dead code elimination in loops.

       -floop-nest-optimize
           Enable the ISL based loop nest optimizer.  This is a generic loop nest optimizer based on the Pluto optimization algorithms.  It calculates a loop structure optimized for data-locality and parallelism.  This option is experimental.

       -floop-parallelize-all
           Use the Graphite data dependence analysis to identify loops that can be parallelized.  Parallelize all the loops that can be analyzed to not contain loop carried dependences without checking that it is profitable to parallelize the loops.

       -fcheck-data-deps
           Compare the results of several data dependence analyzers.  This option is used for debugging the data dependence analyzers.

       -ftree-loop-if-convert
           Attempt to transform conditional jumps in the innermost loops to branch-less equivalents.  The intent is to remove control-flow from the innermost loops in order to improve the ability of the vectorization pass to handle these loops.  This is enabled by default if vectorization is enabled.

       -ftree-loop-if-convert-stores
           Attempt to also if-convert conditional jumps containing memory writes.  This transformation can be unsafe for multi-threaded programs as it transforms conditional memory writes into unconditional memory writes.  For example,

                   for (i = 0; i < N; i++)
                     if (cond)
                       A[i] = expr;

           is transformed to

                   for (i = 0; i < N; i++)
                     A[i] = cond ? expr : A[i];

           potentially producing data races.

       -ftree-loop-distribution
           Perform loop distribution.  This flag can improve cache performance on big loop bodies and allow further loop optimizations, like parallelization or vectorization, to take place.  For example, the loop

                   DO I = 1, N
                     A(I) = B(I) + C
                     D(I) = E(I) * F
                   ENDDO

           is transformed to

                   DO I = 1, N
                      A(I) = B(I) + C
                   ENDDO
                   DO I = 1, N
                      D(I) = E(I) * F
                   ENDDO

       -ftree-loop-distribute-patterns
           Perform loop distribution of patterns that can be code generated with calls to a library.  This flag is enabled by default at -O3.

           This pass distributes the initialization loops and generates a call to memset zero.  For example, the loop

                   DO I = 1, N
                     A(I) = 0
                     B(I) = A(I) + I
                   ENDDO

           is transformed to

                   DO I = 1, N
                      A(I) = 0
                   ENDDO
                   DO I = 1, N
                      B(I) = A(I) + I
                   ENDDO

           and the initialization loop is transformed into a call to memset zero.

       -ftree-loop-im
           Perform loop invariant motion on trees.  This pass moves only invariants that are hard to handle at RTL level (function calls, operations that expand to nontrivial sequences of insns).  With -funswitch-loops it also moves operands of conditions that are invariant out of the loop, so that we can use just trivial invariantness analysis in loop unswitching.  The pass also includes store motion.

       -ftree-loop-ivcanon
           Create a canonical counter for number of iterations in loops for which determining number of iterations requires complicated analysis.  Later optimizations then may determine the number easily.  Useful especially in connection with unrolling.

       -fivopts
           Perform induction variable optimizations (strength reduction, induction variable merging and induction variable elimination) on trees.

       -ftree-parallelize-loops=n
           Parallelize loops, i.e., split their iteration space to run in n threads.  This is only possible for loops whose iterations are independent and can be arbitrarily reordered.  The optimization is only profitable on multiprocessor machines, for loops that are CPU-intensive, rather than constrained e.g. by memory bandwidth.  This option implies -pthread, and thus is only supported on targets that have support for -pthread.

       -ftree-pta
           Perform function-local points-to analysis on trees.  This flag is enabled by default at -O and higher.

       -ftree-sra
           Perform scalar replacement of aggregates.  This pass replaces structure references with scalars to prevent committing structures to memory too early.  This flag is enabled by default at -O and higher.

       -ftree-copyrename
           Perform copy renaming on trees.  This pass attempts to rename compiler temporaries to other variables at copy locations, usually resulting in variable names which more closely resemble the original variables.  This flag is enabled by default at -O and higher.

       -ftree-coalesce-inlined-vars
           Tell the copyrename pass (see -ftree-copyrename) to attempt to combine small user-defined variables too, but only if they were inlined from other functions.  It is a more limited form of -ftree-coalesce-vars.  This may harm debug information of such inlined variables, but it will keep variables of the inlined-into function apart from each other, such that they are more likely to contain the expected values in a debugging session.  This was the default in GCC versions older than 4.7.

       -ftree-coalesce-vars
           Tell the copyrename pass (see -ftree-copyrename) to attempt to combine small user-defined variables too, instead of just compiler temporaries.  This may severely limit the ability to debug an optimized program compiled with -fno-var-tracking-assignments.  In the negated form, this flag prevents SSA coalescing of user variables, including inlined ones.  This option is enabled by default.

       -ftree-ter
           Perform temporary expression replacement during the SSA->normal phase.  Single use/single def temporaries are replaced at their use location with their defining expression.  This results in non-GIMPLE code, but gives the expanders much more complex trees to work on resulting in better RTL generation.  This is enabled by default at -O and higher.

       -ftree-slsr
           Perform straight-line strength reduction on trees.  This recognizes related expressions involving multiplications and replaces them by less expensive calculations when possible.  This is enabled by default at -O and higher.

       -ftree-vectorize
           Perform vectorization on trees. This flag enables -ftree-loop-vectorize and -ftree-slp-vectorize if not explicitly specified.

       -ftree-loop-vectorize
           Perform loop vectorization on trees. This flag is enabled by default at -O3 and when -ftree-vectorize is enabled.

       -ftree-slp-vectorize
           Perform basic block vectorization on trees. This flag is enabled by default at -O3 and when -ftree-vectorize is enabled.

       -fvect-cost-model=model
           Alter the cost model used for vectorization.  The model argument should be one of "unlimited", "dynamic" or "cheap".  With the "unlimited" model the vectorized code-path is assumed to be profitable while with the "dynamic" model a runtime check will guard the vectorized code-path to enable it only for iteration counts that will likely execute faster than when executing the original scalar loop.  The "cheap" model will disable vectorization of loops where doing so would be cost prohibitive for example due to required runtime checks for data dependence or alignment but otherwise is equal to the "dynamic" model.  The default cost model depends on other optimization flags and is either "dynamic" or "cheap".

       -fsimd-cost-model=model
           Alter the cost model used for vectorization of loops marked with the OpenMP or Cilk Plus simd directive.  The model argument should be one of "unlimited", "dynamic", "cheap".  All values of model have the same meaning as described in -fvect-cost-model and by default a cost model defined with -fvect-cost-model is used.

       -ftree-vrp
           Perform Value Range Propagation on trees.  This is similar to the constant propagation pass, but instead of values, ranges of values are propagated.  This allows the optimizers to remove unnecessary range checks like array bound checks and null pointer checks.  This is enabled by default at -O2 and higher.  Null pointer check elimination is only done if -fdelete-null-pointer-checks is enabled.

       -ftracer
           Perform tail duplication to enlarge superblock size.  This transformation simplifies the control flow of the function allowing other optimizations to do a better job.

       -funroll-loops
           Unroll loops whose number of iterations can be determined at compile time or upon entry to the loop.  -funroll-loops implies -frerun-cse-after-loop.  This option makes code larger, and may or may not make it run faster.

       -funroll-all-loops
           Unroll all loops, even if their number of iterations is uncertain when the loop is entered.  This usually makes programs run more slowly.  -funroll-all-loops implies the same options as -funroll-loops,

       -fsplit-ivs-in-unroller
           Enables expression of values of induction variables in later iterations of the unrolled loop using the value in the first iteration.  This breaks long dependency chains, thus improving efficiency of the scheduling passes.

           A combination of -fweb and CSE is often sufficient to obtain the same effect.  However, that is not reliable in cases where the loop body is more complicated than a single basic block.  It also does not work at all on some architectures due to restrictions in the CSE pass.

           This optimization is enabled by default.

       -fvariable-expansion-in-unroller
           With this option, the compiler creates multiple copies of some local variables when unrolling a loop, which can result in superior code.

       -fpartial-inlining
           Inline parts of functions.  This option has any effect only when inlining itself is turned on by the -finline-functions or -finline-small-functions options.

           Enabled at level -O2.

       -fpredictive-commoning
           Perform predictive commoning optimization, i.e., reusing computations (especially memory loads and stores) performed in previous iterations of loops.

           This option is enabled at level -O3.

       -fprefetch-loop-arrays
           If supported by the target machine, generate instructions to prefetch memory to improve the performance of loops that access large arrays.

           This option may generate better or worse code; results are highly dependent on the structure of loops within the source code.

           Disabled at level -Os.

       -fno-peephole
       -fno-peephole2
           Disable any machine-specific peephole optimizations.  The difference between -fno-peephole and -fno-peephole2 is in how they are implemented in the compiler; some targets use one, some use the other, a few use both.

           -fpeephole is enabled by default.  -fpeephole2 enabled at levels -O2, -O3, -Os.

       -fno-guess-branch-probability
           Do not guess branch probabilities using heuristics.

           GCC uses heuristics to guess branch probabilities if they are not provided by profiling feedback (-fprofile-arcs).  These heuristics are based on the control flow graph.  If some branch probabilities are specified by __builtin_expect, then the heuristics are used to guess branch probabilities for the rest of the control flow graph, taking the __builtin_expect info into account.  The interactions between the heuristics and __builtin_expect can be complex, and in some cases, it may be useful to disable the heuristics so that the effects of __builtin_expect are easier to understand.

           The default is -fguess-branch-probability at levels -O, -O2, -O3, -Os.

       -freorder-blocks
           Reorder basic blocks in the compiled function in order to reduce number of taken branches and improve code locality.

           Enabled at levels -O2, -O3.

       -freorder-blocks-and-partition
           In addition to reordering basic blocks in the compiled function, in order to reduce number of taken branches, partitions hot and cold basic blocks into separate sections of the assembly and .o files, to improve paging and cache locality performance.

           This optimization is automatically turned off in the presence of exception handling, for linkonce sections, for functions with a user-defined section attribute and on any architecture that does not support named sections.

           Enabled for x86 at levels -O2, -O3.

       -freorder-functions
           Reorder functions in the object file in order to improve code locality.  This is implemented by using special subsections ".text.hot" for most frequently executed functions and ".text.unlikely" for unlikely executed functions.  Reordering is done by the linker so object file format must support named sections and linker must place them in a reasonable way.

           Also profile feedback must be available to make this option effective.  See -fprofile-arcs for details.

           Enabled at levels -O2, -O3, -Os.

       -fstrict-aliasing
           Allow the compiler to assume the strictest aliasing rules applicable to the language being compiled.  For C (and C++), this activates optimizations based on the type of expressions.  In particular, an object of one type is assumed never to reside at the same address as an object of a different type, unless the types are almost the same.  For example, an "unsigned int" can alias an "int", but not a "void*" or a "double".  A character type may alias any other type.

           Pay special attention to code like this:

                   union a_union {
                     int i;
                     double d;
                   };

                   int f() {
                     union a_union t;
                     t.d = 3.0;
                     return t.i;
                   }

           The practice of reading from a different union member than the one most recently written to (called "type-punning") is common.  Even with -fstrict-aliasing, type-punning is allowed, provided the memory is accessed through the union type.  So, the code above works as expected.    However, this code might not:

                   int f() {
                     union a_union t;
                     int* ip;
                     t.d = 3.0;
                     ip = &t.i;
                     return *ip;
                   }

           Similarly, access by taking the address, casting the resulting pointer and dereferencing the result has undefined behavior, even if the cast uses a union type, e.g.:

                   int f() {
                     double d = 3.0;
                     return ((union a_union *) &d)->i;
                   }

           The -fstrict-aliasing option is enabled at levels -O2, -O3, -Os.

       -fstrict-overflow
           Allow the compiler to assume strict signed overflow rules, depending on the language being compiled.  For C (and C++) this means that overflow when doing arithmetic with signed numbers is undefined, which means that the compiler may assume that it does not happen.  This permits various optimizations.  For example, the compiler assumes that an expression like "i + 10 > i" is always true for signed "i".  This assumption is only valid if signed overflow is undefined, as the expression is false if "i + 10" overflows when using twos complement arithmetic.  When this option is in effect any attempt to determine whether an operation on signed numbers overflows must be written carefully to not actually involve overflow.

           This option also allows the compiler to assume strict pointer semantics: given a pointer to an object, if adding an offset to that pointer does not produce a pointer to the same object, the addition is undefined.  This permits the compiler to conclude that "p + u > p" is always true for a pointer "p" and unsigned integer "u".  This assumption is only valid because pointer wraparound is undefined, as the expression is false if "p + u" overflows using twos complement arithmetic.

           See also the -fwrapv option.  Using -fwrapv means that integer signed overflow is fully defined: it wraps.  When -fwrapv is used, there is no difference between -fstrict-overflow and -fno-strict-overflow for integers.  With -fwrapv certain types of overflow are permitted.  For example, if the compiler gets an overflow when doing arithmetic on constants, the overflowed value can still be used with -fwrapv, but not otherwise.

           The -fstrict-overflow option is enabled at levels -O2, -O3, -Os.

       -falign-functions
       -falign-functions=n
           Align the start of functions to the next power-of-two greater than n, skipping up to n bytes.  For instance, -falign-functions=32 aligns functions to the next 32-byte boundary, but -falign-functions=24 aligns to the next 32-byte boundary only if this can be done by skipping 23 bytes or less.

           -fno-align-functions and -falign-functions=1 are equivalent and mean that functions are not aligned.

           Some assemblers only support this flag when n is a power of two; in that case, it is rounded up.

           If n is not specified or is zero, use a machine-dependent default.

           Enabled at levels -O2, -O3.

       -falign-labels
       -falign-labels=n
           Align all branch targets to a power-of-two boundary, skipping up to n bytes like -falign-functions.  This option can easily make code slower, because it must insert dummy operations for when the branch target is reached in the usual flow of the code.

           -fno-align-labels and -falign-labels=1 are equivalent and mean that labels are not aligned.

           If -falign-loops or -falign-jumps are applicable and are greater than this value, then their values are used instead.

           If n is not specified or is zero, use a machine-dependent default which is very likely to be 1, meaning no alignment.

           Enabled at levels -O2, -O3.

       -falign-loops
       -falign-loops=n
           Align loops to a power-of-two boundary, skipping up to n bytes like -falign-functions.  If the loops are executed many times, this makes up for any execution of the dummy operations.

           -fno-align-loops and -falign-loops=1 are equivalent and mean that loops are not aligned.

           If n is not specified or is zero, use a machine-dependent default.

           Enabled at levels -O2, -O3.

       -falign-jumps
       -falign-jumps=n
           Align branch targets to a power-of-two boundary, for branch targets where the targets can only be reached by jumping, skipping up to n bytes like -falign-functions.  In this case, no dummy operations need be executed.

           -fno-align-jumps and -falign-jumps=1 are equivalent and mean that loops are not aligned.

           If n is not specified or is zero, use a machine-dependent default.

           Enabled at levels -O2, -O3.

       -funit-at-a-time
           This option is left for compatibility reasons. -funit-at-a-time has no effect, while -fno-unit-at-a-time implies -fno-toplevel-reorder and -fno-section-anchors.

           Enabled by default.

       -fno-toplevel-reorder
           Do not reorder top-level functions, variables, and "asm" statements.  Output them in the same order that they appear in the input file.  When this option is used, unreferenced static variables are not removed.  This option is intended to support existing code that relies on a particular ordering.  For new code, it is better to use attributes when possible.

           Enabled at level -O0.  When disabled explicitly, it also implies -fno-section-anchors, which is otherwise enabled at -O0 on some targets.

       -fweb
           Constructs webs as commonly used for register allocation purposes and assign each web individual pseudo register.  This allows the register allocation pass to operate on pseudos directly, but also strengthens several other optimization passes, such as CSE, loop optimizer and trivial dead code remover.  It can, however, make debugging impossible, since variables no longer stay in a "home register".

           Enabled by default with -funroll-loops.

       -fwhole-program
           Assume that the current compilation unit represents the whole program being compiled.  All public functions and variables with the exception of "main" and those merged by attribute "externally_visible" become static functions and in effect are optimized more aggressively by interprocedural optimizers.

           This option should not be used in combination with "-flto".  Instead relying on a linker plugin should provide safer and more precise information.

       -flto[=n]
           This option runs the standard link-time optimizer.  When invoked with source code, it generates GIMPLE (one of GCC's internal representations) and writes it to special ELF sections in the object file.  When the object files are linked together, all the function bodies are read from these ELF sections and instantiated as if they had been part of the same translation unit.

           To use the link-time optimizer, -flto and optimization options should be specified at compile time and during the final link.  For example:

                   gcc -c -O2 -flto foo.c
                   gcc -c -O2 -flto bar.c
                   gcc -o myprog -flto -O2 foo.o bar.o

           The first two invocations to GCC save a bytecode representation of GIMPLE into special ELF sections inside foo.o and bar.o.  The final invocation reads the GIMPLE bytecode from foo.o and bar.o, merges the two files into a single internal image, and compiles the result as usual.  Since both foo.o and bar.o are merged into a single image, this causes all the interprocedural analyses and optimizations in GCC to work across the two files as if they were a single one.  This means, for example, that the inliner is able to inline functions in bar.o into functions in foo.o and vice-versa.

           Another (simpler) way to enable link-time optimization is:

                   gcc -o myprog -flto -O2 foo.c bar.c

           The above generates bytecode for foo.c and bar.c, merges them together into a single GIMPLE representation and optimizes them as usual to produce myprog.

           The only important thing to keep in mind is that to enable link-time optimizations you need to use the GCC driver to perform the link-step.  GCC then automatically performs link-time optimization if any of the objects involved were compiled with the -flto.  You generally should specify the optimization options to be used for link-time optimization though GCC will try to be clever at guessing an optimization level to use from the options used at compile-time if you fail to specify one at link-time.  You can always override the automatic decision to do link-time optimization at link-time by passing -fno-lto to the link command.

           To make whole program optimization effective, it is necessary to make certain whole program assumptions.  The compiler needs to know what functions and variables can be accessed by libraries and runtime outside of the link-time optimized unit.  When supported by the linker, the linker plugin (see -fuse-linker-plugin) passes information to the compiler about used and externally visible symbols.  When the linker plugin is not available, -fwhole-program should be used to allow the compiler to make these assumptions, which leads to more aggressive optimization decisions.

           When -fuse-linker-plugin is not enabled then, when a file is compiled with -flto, the generated object file is larger than a regular object file because it contains GIMPLE bytecodes and the usual final code (see -ffat-lto-objects.  This means that object files with LTO information can be linked as normal object files; if -fno-lto is passed to the linker, no interprocedural optimizations are applied.  Note that when -fno-fat-lto-objects is enabled the compile-stage is faster but you cannot perform a regular, non-LTO link on them.

           Additionally, the optimization flags used to compile individual files are not necessarily related to those used at link time.  For instance,

                   gcc -c -O0 -ffat-lto-objects -flto foo.c
                   gcc -c -O0 -ffat-lto-objects -flto bar.c
                   gcc -o myprog -O3 foo.o bar.o

           This produces individual object files with unoptimized assembler code, but the resulting binary myprog is optimized at -O3.  If, instead, the final binary is generated with -fno-lto, then myprog is not optimized.

           When producing the final binary, GCC only applies link-time optimizations to those files that contain bytecode.  Therefore, you can mix and match object files and libraries with GIMPLE bytecodes and final object code.  GCC automatically selects which files to optimize in LTO mode and which files to link without further processing.

           There are some code generation flags preserved by GCC when generating bytecodes, as they need to be used during the final link stage.  Generally options specified at link-time override those specified at compile-time.

           If you do not specify an optimization level option -O at link-time then GCC will compute one based on the optimization levels used when compiling the object files.  The highest optimization level will win here.

           Currently, the following options and their setting are take from the first object file that explicitely specified it: -fPIC, -fpic, -fpie, -fcommon, -fexceptions, -fnon-call-exceptions, -fgnu-tm and all the -m target flags.

           Certain ABI changing flags are required to match in all compilation-units and trying to override this at link-time with a conflicting value is ignored.  This includes options such as -freg-struct-return and -fpcc-struct-return.

           Other options such as -ffp-contract, -fno-strict-overflow, -fwrapv, -fno-trapv or -fno-strict-aliasing are passed through to the link stage and merged conservatively for conflicting translation units.  Specifically -fno-strict-overflow, -fwrapv and -fno-trapv take precedence and for example -ffp-contract=off takes precedence over -ffp-contract=fast.  You can override them at linke-time.

           It is recommended that you compile all the files participating in the same link with the same options and also specify those options at link time.

           If LTO encounters objects with C linkage declared with incompatible types in separate translation units to be linked together (undefined behavior according to ISO C99 6.2.7), a non-fatal diagnostic may be issued.  The behavior is still undefined at run time.  Similar diagnostics may be raised for other languages.

           Another feature of LTO is that it is possible to apply interprocedural optimizations on files written in different languages:

                   gcc -c -flto foo.c
                   g++ -c -flto bar.cc
                   gfortran -c -flto baz.f90
                   g++ -o myprog -flto -O3 foo.o bar.o baz.o -lgfortran

           Notice that the final link is done with g++ to get the C++ runtime libraries and -lgfortran is added to get the Fortran runtime libraries.  In general, when mixing languages in LTO mode, you should use the same link command options as when mixing languages in a regular (non-LTO) compilation.

           If object files containing GIMPLE bytecode are stored in a library archive, say libfoo.a, it is possible to extract and use them in an LTO link if you are using a linker with plugin support.  To create static libraries suitable for LTO, use gcc-ar and gcc-ranlib instead of ar and "ranlib"; to show the symbols of object files with GIMPLE bytecode, use gcc-nm.  Those commands require that ar, ranlib and nm have been compiled with plugin support.  At link time, use the the flag -fuse-linker-plugin to ensure that the library participates in the LTO optimization process:

                   gcc -o myprog -O2 -flto -fuse-linker-plugin a.o b.o -lfoo

           With the linker plugin enabled, the linker extracts the needed GIMPLE files from libfoo.a and passes them on to the running GCC to make them part of the aggregated GIMPLE image to be optimized.

           If you are not using a linker with plugin support and/or do not enable the linker plugin, then the objects inside libfoo.a are extracted and linked as usual, but they do not participate in the LTO optimization process.  In order to make a static library suitable for both LTO optimization and usual linkage, compile its object files with -flto "-ffat-lto-objects".

           Link-time optimizations do not require the presence of the whole program to operate.  If the program does not require any symbols to be exported, it is possible to combine -flto and -fwhole-program to allow the interprocedural optimizers to use more aggressive assumptions which may lead to improved optimization opportunities.  Use of -fwhole-program is not needed when linker plugin is active (see -fuse-linker-plugin).

           The current implementation of LTO makes no attempt to generate bytecode that is portable between different types of hosts.  The bytecode files are versioned and there is a strict version check, so bytecode files generated in one version of GCC will not work with an older or newer version of GCC.

           Link-time optimization does not work well with generation of debugging information.  Combining -flto with -g is currently experimental and expected to produce unexpected results.

           If you specify the optional n, the optimization and code generation done at link time is executed in parallel using n parallel jobs by utilizing an installed make program.  The environment variable MAKE may be used to override the program used.  The default value for n is 1.

           You can also specify -flto=jobserver to use GNU make's job server mode to determine the number of parallel jobs. This is useful when the Makefile calling GCC is already executing in parallel.  You must prepend a + to the command recipe in the parent Makefile for this to work.  This option likely only works if MAKE is GNU make.

       -flto-partition=alg
           Specify the partitioning algorithm used by the link-time optimizer.  The value is either "1to1" to specify a partitioning mirroring the original source files or "balanced" to specify partitioning into equally sized chunks (whenever possible) or "max" to create new partition for every symbol where possible.  Specifying "none" as an algorithm disables partitioning and streaming completely.  The default value is "balanced". While "1to1" can be used as an workaround for various code ordering issues, the "max" partitioning is intended for internal testing only.

       -flto-compression-level=n
           This option specifies the level of compression used for intermediate language written to LTO object files, and is only meaningful in conjunction with LTO mode (-flto).  Valid values are 0 (no compression) to 9 (maximum compression).  Values outside this range are clamped to either 0 or 9.  If the option is not given, a default balanced compression setting is used.

       -flto-report
           Prints a report with internal details on the workings of the link-time optimizer.  The contents of this report vary from version to version.  It is meant to be useful to GCC developers when processing object files in LTO mode (via -flto).

           Disabled by default.

       -flto-report-wpa
           Like -flto-report, but only print for the WPA phase of Link Time Optimization.

       -fuse-linker-plugin
           Enables the use of a linker plugin during link-time optimization.  This option relies on plugin support in the linker, which is available in gold or in GNU ld 2.21 or newer.

           This option enables the extraction of object files with GIMPLE bytecode out of library archives. This improves the quality of optimization by exposing more code to the link-time optimizer.  This information specifies what symbols can be accessed externally (by non-LTO object or during dynamic linking).  Resulting code quality improvements on binaries (and shared libraries that use hidden visibility) are similar to "-fwhole-program".  See -flto for a description of the effect of this flag and how to use it.

           This option is enabled by default when LTO support in GCC is enabled and GCC was configured for use with a linker supporting plugins (GNU ld 2.21 or newer or gold).

       -ffat-lto-objects
           Fat LTO objects are object files that contain both the intermediate language and the object code. This makes them usable for both LTO linking and normal linking. This option is effective only when compiling with -flto and is ignored at link time.

           -fno-fat-lto-objects improves compilation time over plain LTO, but requires the complete toolchain to be aware of LTO. It requires a linker with linker plugin support for basic functionality.  Additionally, nm, ar and ranlib need to support linker plugins to allow a full-featured build environment (capable of building static libraries etc).  GCC provides the gcc-ar, gcc-nm, gcc-ranlib wrappers to pass the right options to these tools. With non fat LTO makefiles need to be modified to use them.

           The default is -fno-fat-lto-objects on targets with linker plugin support.

       -fcompare-elim
           After register allocation and post-register allocation instruction splitting, identify arithmetic instructions that compute processor flags similar to a comparison operation based on that arithmetic.  If possible, eliminate the explicit comparison operation.

           This pass only applies to certain targets that cannot explicitly represent the comparison operation before register allocation is complete.

           Enabled at levels -O, -O2, -O3, -Os.

       -fuse-ld=bfd
           Use the bfd linker instead of the default linker.

       -fuse-ld=gold
           Use the gold linker instead of the default linker.

       -fcprop-registers
           After register allocation and post-register allocation instruction splitting, perform a copy-propagation pass to try to reduce scheduling dependencies and occasionally eliminate the copy.

           Enabled at levels -O, -O2, -O3, -Os.

       -fprofile-correction
           Profiles collected using an instrumented binary for multi-threaded programs may be inconsistent due to missed counter updates. When this option is specified, GCC uses heuristics to correct or smooth out such inconsistencies. By default, GCC emits an error message when an inconsistent profile is detected.

       -fprofile-dir=path
           Set the directory to search for the profile data files in to path.  This option affects only the profile data generated by -fprofile-generate, -ftest-coverage, -fprofile-arcs and used by -fprofile-use and -fbranch-probabilities and its related options.  Both absolute and relative paths can be used.  By default, GCC uses the current directory as path, thus the profile data file appears in the same directory as the object file.

       -fprofile-generate
       -fprofile-generate=path
           Enable options usually used for instrumenting application to produce profile useful for later recompilation with profile feedback based optimization.  You must use -fprofile-generate both when compiling and when linking your program.

           The following options are enabled: "-fprofile-arcs", "-fprofile-values", "-fvpt".

           If path is specified, GCC looks at the path to find the profile feedback data files. See -fprofile-dir.

       -fprofile-use
       -fprofile-use=path
           Enable profile feedback directed optimizations, and optimizations generally profitable only with profile feedback available.

           The following options are enabled: "-fbranch-probabilities", "-fvpt", "-funroll-loops", "-fpeel-loops", "-ftracer", "-ftree-vectorize", "ftree-loop-distribute-patterns"

           By default, GCC emits an error message if the feedback profiles do not match the source code.  This error can be turned into a warning by using -Wcoverage-mismatch.  Note this may result in poorly optimized code.

           If path is specified, GCC looks at the path to find the profile feedback data files. See -fprofile-dir.

       The following options control compiler behavior regarding floating-point arithmetic.  These options trade off between speed and correctness.  All must be specifically enabled.

       -ffloat-store
           Do not store floating-point variables in registers, and inhibit other options that might change whether a floating-point value is taken from a register or memory.

           This option prevents undesirable excess precision on machines such as the 68000 where the floating registers (of the 68881) keep more precision than a "double" is supposed to have.  Similarly for the x86 architecture.  For most programs, the excess precision does only good, but a few programs rely on the precise definition of IEEE floating point.  Use -ffloat-store for such programs, after modifying them to store all pertinent intermediate computations into variables.

       -fexcess-precision=style
           This option allows further control over excess precision on machines where floating-point registers have more precision than the IEEE "float" and "double" types and the processor does not support operations rounding to those types.  By default, -fexcess-precision=fast is in effect; this means that operations are carried out in the precision of the registers and that it is unpredictable when rounding to the types specified in the source code takes place.  When compiling C, if -fexcess-precision=standard is specified then excess precision follows the rules specified in ISO C99; in particular, both casts and assignments cause values to be rounded to their semantic types (whereas -ffloat-store only affects assignments).  This option is enabled by default for C if a strict conformance option such as -std=c99 is used.

           -fexcess-precision=standard is not implemented for languages other than C, and has no effect if -funsafe-math-optimizations or -ffast-math is specified.  On the x86, it also has no effect if -mfpmath=sse or -mfpmath=sse+387 is specified; in the former case, IEEE semantics apply without excess precision, and in the latter, rounding is unpredictable.

       -ffast-math
           Sets -fno-math-errno, -funsafe-math-optimizations, -ffinite-math-only, -fno-rounding-math, -fno-signaling-nans and -fcx-limited-range.

           This option causes the preprocessor macro "__FAST_MATH__" to be defined.

           This option is not turned on by any -O option besides -Ofast since it can result in incorrect output for programs that depend on an exact implementation of IEEE or ISO rules/specifications for math functions. It may, however, yield faster code for programs that do not require the guarantees of these specifications.

       -fno-math-errno
           Do not set "errno" after calling math functions that are executed with a single instruction, e.g., "sqrt".  A program that relies on IEEE exceptions for math error handling may want to use this flag for speed while maintaining IEEE arithmetic compatibility.

           This option is not turned on by any -O option since it can result in incorrect output for programs that depend on an exact implementation of IEEE or ISO rules/specifications for math functions. It may, however, yield faster code for programs that do not require the guarantees of these specifications.

           The default is -fmath-errno.

           On Darwin systems, the math library never sets "errno".  There is therefore no reason for the compiler to consider the possibility that it might, and -fno-math-errno is the default.

       -funsafe-math-optimizations
           Allow optimizations for floating-point arithmetic that (a) assume that arguments and results are valid and (b) may violate IEEE or ANSI standards.  When used at link-time, it may include libraries or startup files that change the default FPU control word or other similar optimizations.

           This option is not turned on by any -O option since it can result in incorrect output for programs that depend on an exact implementation of IEEE or ISO rules/specifications for math functions. It may, however, yield faster code for programs that do not require the guarantees of these specifications.  Enables -fno-signed-zeros, -fno-trapping-math, -fassociative-math and -freciprocal-math.

           The default is -fno-unsafe-math-optimizations.

       -fassociative-math
           Allow re-association of operands in series of floating-point operations.  This violates the ISO C and C++ language standard by possibly changing computation result.  NOTE: re-ordering may change the sign of zero as well as ignore NaNs and inhibit or create underflow or overflow (and thus cannot be used on code that relies on rounding behavior like "(x + 2**52) - 2**52".  May also reorder floating-point comparisons and thus may not be used when ordered comparisons are required.  This option requires that both -fno-signed-zeros and -fno-trapping-math be in effect.  Moreover, it doesn't make much sense with -frounding-math. For Fortran the option is automatically enabled when both -fno-signed-zeros and -fno-trapping-math are in effect.

           The default is -fno-associative-math.

       -freciprocal-math
           Allow the reciprocal of a value to be used instead of dividing by the value if this enables optimizations.  For example "x / y" can be replaced with "x * (1/y)", which is useful if "(1/y)" is subject to common subexpression elimination.  Note that this loses precision and increases the number of flops operating on the value.

           The default is -fno-reciprocal-math.

       -ffinite-math-only
           Allow optimizations for floating-point arithmetic that assume that arguments and results are not NaNs or +-Infs.

           This option is not turned on by any -O option since it can result in incorrect output for programs that depend on an exact implementation of IEEE or ISO rules/specifications for math functions. It may, however, yield faster code for programs that do not require the guarantees of these specifications.

           The default is -fno-finite-math-only.

       -fno-signed-zeros
           Allow optimizations for floating-point arithmetic that ignore the signedness of zero.  IEEE arithmetic specifies the behavior of distinct +0.0 and -0.0 values, which then prohibits simplification of expressions such as x+0.0 or 0.0*x (even with -ffinite-math-only).  This option implies that the sign of a zero result isn't significant.

           The default is -fsigned-zeros.

       -fno-trapping-math
           Compile code assuming that floating-point operations cannot generate user-visible traps.  These traps include division by zero, overflow, underflow, inexact result and invalid operation.  This option requires that -fno-signaling-nans be in effect.  Setting this option may allow faster code if one relies on "non-stop" IEEE arithmetic, for example.

           This option should never be turned on by any -O option since it can result in incorrect output for programs that depend on an exact implementation of IEEE or ISO rules/specifications for math functions.

           The default is -ftrapping-math.

       -frounding-math
           Disable transformations and optimizations that assume default floating-point rounding behavior.  This is round-to-zero for all floating point to integer conversions, and round-to-nearest for all other arithmetic truncations.  This option should be specified for programs that change the FP rounding mode dynamically, or that may be executed with a non-default rounding mode.  This option disables constant folding of floating-point expressions at compile time (which may be affected by rounding mode) and arithmetic transformations that are unsafe in the presence of sign-dependent rounding modes.

           The default is -fno-rounding-math.

           This option is experimental and does not currently guarantee to disable all GCC optimizations that are affected by rounding mode.  Future versions of GCC may provide finer control of this setting using C99's "FENV_ACCESS" pragma.  This command-line option will be used to specify the default state for "FENV_ACCESS".

       -fsignaling-nans
           Compile code assuming that IEEE signaling NaNs may generate user-visible traps during floating-point operations.  Setting this option disables optimizations that may change the number of exceptions visible with signaling NaNs.  This option implies -ftrapping-math.

           This option causes the preprocessor macro "__SUPPORT_SNAN__" to be defined.

           The default is -fno-signaling-nans.

           This option is experimental and does not currently guarantee to disable all GCC optimizations that affect signaling NaN behavior.

       -fsingle-precision-constant
           Treat floating-point constants as single precision instead of implicitly converting them to double-precision constants.

       -fcx-limited-range
           When enabled, this option states that a range reduction step is not needed when performing complex division.  Also, there is no checking whether the result of a complex multiplication or division is "NaN + I*NaN", with an attempt to rescue the situation in that case.  The default is -fno-cx-limited-range, but is enabled by -ffast-math.

           This option controls the default setting of the ISO C99 "CX_LIMITED_RANGE" pragma.  Nevertheless, the option applies to all languages.

       -fcx-fortran-rules
           Complex multiplication and division follow Fortran rules.  Range reduction is done as part of complex division, but there is no checking whether the result of a complex multiplication or division is "NaN + I*NaN", with an attempt to rescue the situation in that case.

           The default is -fno-cx-fortran-rules.

       The following options control optimizations that may improve performance, but are not enabled by any -O options.  This section includes experimental options that may produce broken code.

       -fbranch-probabilities
           After running a program compiled with -fprofile-arcs, you can compile it a second time using -fbranch-probabilities, to improve optimizations based on the number of times each branch was taken.  When a program compiled with -fprofile-arcs exits, it saves arc execution counts to a file called sourcename.gcda for each source file.  The information in this data file is very dependent on the structure of the generated code, so you must use the same source code and the same optimization options for both compilations.

           With -fbranch-probabilities, GCC puts a REG_BR_PROB note on each JUMP_INSN and CALL_INSN.  These can be used to improve optimization.  Currently, they are only used in one place: in reorg.c, instead of guessing which path a branch is most likely to take, the REG_BR_PROB values are used to exactly determine which path is taken more often.

       -fprofile-values
           If combined with -fprofile-arcs, it adds code so that some data about values of expressions in the program is gathered.

           With -fbranch-probabilities, it reads back the data gathered from profiling values of expressions for usage in optimizations.

           Enabled with -fprofile-generate and -fprofile-use.

       -fprofile-reorder-functions
           Function reordering based on profile instrumentation collects first time of execution of a function and orders these functions in ascending order.

           Enabled with -fprofile-use.

       -fvpt
           If combined with -fprofile-arcs, this option instructs the compiler to add code to gather information about values of expressions.

           With -fbranch-probabilities, it reads back the data gathered and actually performs the optimizations based on them.  Currently the optimizations include specialization of division operations using the knowledge about the value of the denominator.

       -frename-registers
           Attempt to avoid false dependencies in scheduled code by making use of registers left over after register allocation.  This optimization most benefits processors with lots of registers.  Depending on the debug information format adopted by the target, however, it can make debugging impossible, since variables no longer stay in a "home register".

           Enabled by default with -funroll-loops and -fpeel-loops.

       -ftracer
           Perform tail duplication to enlarge superblock size.  This transformation simplifies the control flow of the function allowing other optimizations to do a better job.

           Enabled with -fprofile-use.

       -funroll-loops
           Unroll loops whose number of iterations can be determined at compile time or upon entry to the loop.  -funroll-loops implies -frerun-cse-after-loop, -fweb and -frename-registers.  It also turns on complete loop peeling (i.e. complete removal of loops with a small constant number of iterations).  This option makes code larger, and may or may not make it run faster.

           Enabled with -fprofile-use.

       -funroll-all-loops
           Unroll all loops, even if their number of iterations is uncertain when the loop is entered.  This usually makes programs run more slowly.  -funroll-all-loops implies the same options as -funroll-loops.

       -fpeel-loops
           Peels loops for which there is enough information that they do not roll much (from profile feedback).  It also turns on complete loop peeling (i.e. complete removal of loops with small constant number of iterations).

           Enabled with -fprofile-use.

       -fmove-loop-invariants
           Enables the loop invariant motion pass in the RTL loop optimizer.  Enabled at level -O1

       -funswitch-loops
           Move branches with loop invariant conditions out of the loop, with duplicates of the loop on both branches (modified according to result of the condition).

       -ffunction-sections
       -fdata-sections
           Place each function or data item into its own section in the output file if the target supports arbitrary sections.  The name of the function or the name of the data item determines the section's name in the output file.

           Use these options on systems where the linker can perform optimizations to improve locality of reference in the instruction space.  Most systems using the ELF object format and SPARC processors running Solaris 2 have linkers with such optimizations.  AIX may have these optimizations in the future.

           Only use these options when there are significant benefits from doing so.  When you specify these options, the assembler and linker create larger object and executable files and are also slower.  You cannot use "gprof" on all systems if you specify this option, and you may have problems with debugging if you specify both this option and -g.

       -fbranch-target-load-optimize
           Perform branch target register load optimization before prologue / epilogue threading.  The use of target registers can typically be exposed only during reload, thus hoisting loads out of loops and doing inter-block scheduling needs a separate optimization pass.

       -fbranch-target-load-optimize2
           Perform branch target register load optimization after prologue / epilogue threading.

       -fbtr-bb-exclusive
           When performing branch target register load optimization, don't reuse branch target registers within any basic block.

       -fstack-protector
           Emit extra code to check for buffer overflows, such as stack smashing attacks.  This is done by adding a guard variable to functions with vulnerable objects.  This includes functions that call "alloca", and functions with buffers larger than 8 bytes.  The guards are initialized when a function is entered and then checked when the function exits.  If a guard check fails, an error message is printed and the program exits.

       -fstack-protector-all
           Like -fstack-protector except that all functions are protected.

       -fstack-protector-strong
           Like -fstack-protector but includes additional functions to be protected --- those that have local array definitions, or have references to local frame addresses.

           NOTE: In Ubuntu 14.10 and later versions, -fstack-protector-strong is enabled by default for C, C++, ObjC, ObjC++, if none of -fno-stack-protector, -nostdlib, nor -ffreestanding are found.

       -fsection-anchors
           Try to reduce the number of symbolic address calculations by using shared "anchor" symbols to address nearby objects.  This transformation can help to reduce the number of GOT entries and GOT accesses on some targets.

           For example, the implementation of the following function "foo":

                   static int a, b, c;
                   int foo (void) { return a + b + c; }

           usually calculates the addresses of all three variables, but if you compile it with -fsection-anchors, it accesses the variables from a common anchor point instead.  The effect is similar to the following pseudocode (which isn't valid C):

                   int foo (void)
                   {
                     register int *xr = &x;
                     return xr[&a - &x] + xr[&b - &x] + xr[&c - &x];
                   }

           Not all targets support this option.

       --param name=value
           In some places, GCC uses various constants to control the amount of optimization that is done.  For example, GCC does not inline functions that contain more than a certain number of instructions.  You can control some of these constants on the command line using the --param option.

           The names of specific parameters, and the meaning of the values, are tied to the internals of the compiler, and are subject to change without notice in future releases.

           In each case, the value is an integer.  The allowable choices for name are:

           predictable-branch-outcome
               When branch is predicted to be taken with probability lower than this threshold (in percent), then it is considered well predictable. The default is 10.

           max-crossjump-edges
               The maximum number of incoming edges to consider for cross-jumping.  The algorithm used by -fcrossjumping is O(N^2) in the number of edges incoming to each block.  Increasing values mean more aggressive optimization, making the compilation time increase with probably small improvement in executable size.

           min-crossjump-insns
               The minimum number of instructions that must be matched at the end of two blocks before cross-jumping is performed on them.  This value is ignored in the case where all instructions in the block being cross-jumped from are matched.  The default value is 5.

           max-grow-copy-bb-insns
               The maximum code size expansion factor when copying basic blocks instead of jumping.  The expansion is relative to a jump instruction.  The default value is 8.

           max-goto-duplication-insns
               The maximum number of instructions to duplicate to a block that jumps to a computed goto.  To avoid O(N^2) behavior in a number of passes, GCC factors computed gotos early in the compilation process, and unfactors them as late as possible.  Only computed jumps at the end of a basic blocks with no more than max-goto-duplication-insns are unfactored.  The default value is 8.

           max-delay-slot-insn-search
               The maximum number of instructions to consider when looking for an instruction to fill a delay slot.  If more than this arbitrary number of instructions are searched, the time savings from filling the delay slot are minimal, so stop searching.  Increasing values mean more aggressive optimization, making the compilation time increase with probably small improvement in execution time.

           max-delay-slot-live-search
               When trying to fill delay slots, the maximum number of instructions to consider when searching for a block with valid live register information.  Increasing this arbitrarily chosen value means more aggressive optimization, increasing the compilation time.  This parameter should be removed when the delay slot code is rewritten to maintain the control-flow graph.

           max-gcse-memory
               The approximate maximum amount of memory that can be allocated in order to perform the global common subexpression elimination optimization.  If more memory than specified is required, the optimization is not done.

           max-gcse-insertion-ratio
               If the ratio of expression insertions to deletions is larger than this value for any expression, then RTL PRE inserts or removes the expression and thus leaves partially redundant computations in the instruction stream.  The default value is 20.

           max-pending-list-length
               The maximum number of pending dependencies scheduling allows before flushing the current state and starting over.  Large functions with few branches or calls can create excessively large lists which needlessly consume memory and resources.

           max-modulo-backtrack-attempts
               The maximum number of backtrack attempts the scheduler should make when modulo scheduling a loop.  Larger values can exponentially increase compilation time.

           max-inline-insns-single
               Several parameters control the tree inliner used in GCC.  This number sets the maximum number of instructions (counted in GCC's internal representation) in a single function that the tree inliner considers for inlining.  This only affects functions declared inline and methods implemented in a class declaration (C++).  The default value is 400.

           max-inline-insns-auto
               When you use -finline-functions (included in -O3), a lot of functions that would otherwise not be considered for inlining by the compiler are investigated.  To those functions, a different (more restrictive) limit compared to functions declared inline can be applied.  The default value is 40.

           inline-min-speedup
               When estimated performance improvement of caller + callee runtime exceeds this threshold (in precent), the function can be inlined regardless the limit on --param max-inline-insns-single and --param max-inline-insns-auto.

           large-function-insns
               The limit specifying really large functions.  For functions larger than this limit after inlining, inlining is constrained by --param large-function-growth.  This parameter is useful primarily to avoid extreme compilation time caused by non-linear algorithms used by the back end.  The default value is 2700.

           large-function-growth
               Specifies maximal growth of large function caused by inlining in percents.  The default value is 100 which limits large function growth to 2.0 times the original size.

           large-unit-insns
               The limit specifying large translation unit.  Growth caused by inlining of units larger than this limit is limited by --param inline-unit-growth.  For small units this might be too tight.  For example, consider a unit consisting of function A that is inline and B that just calls A three times.  If B is small relative to A, the growth of unit is 300\% and yet such inlining is very sane.  For very large units consisting of small inlineable functions, however, the overall unit growth limit is needed to avoid exponential explosion of code size.  Thus for smaller units, the size is increased to --param large-unit-insns before applying --param inline-unit-growth.  The default is 10000.

           inline-unit-growth
               Specifies maximal overall growth of the compilation unit caused by inlining.  The default value is 30 which limits unit growth to 1.3 times the original size.

           ipcp-unit-growth
               Specifies maximal overall growth of the compilation unit caused by interprocedural constant propagation.  The default value is 10 which limits unit growth to 1.1 times the original size.

           large-stack-frame
               The limit specifying large stack frames.  While inlining the algorithm is trying to not grow past this limit too much.  The default value is 256 bytes.

           large-stack-frame-growth
               Specifies maximal growth of large stack frames caused by inlining in percents.  The default value is 1000 which limits large stack frame growth to 11 times the original size.

           max-inline-insns-recursive
           max-inline-insns-recursive-auto
               Specifies the maximum number of instructions an out-of-line copy of a self-recursive inline function can grow into by performing recursive inlining.

               For functions declared inline, --param max-inline-insns-recursive is taken into account.  For functions not declared inline, recursive inlining happens only when -finline-functions (included in -O3) is enabled and --param max-inline-insns-recursive-auto is used.  The default value is 450.

           max-inline-recursive-depth
           max-inline-recursive-depth-auto
               Specifies the maximum recursion depth used for recursive inlining.

               For functions declared inline, --param max-inline-recursive-depth is taken into account.  For functions not declared inline, recursive inlining happens only when -finline-functions (included in -O3) is enabled and --param max-inline-recursive-depth-auto is used.  The default value is 8.

           min-inline-recursive-probability
               Recursive inlining is profitable only for function having deep recursion in average and can hurt for function having little recursion depth by increasing the prologue size or complexity of function body to other optimizers.

               When profile feedback is available (see -fprofile-generate) the actual recursion depth can be guessed from probability that function recurses via a given call expression.  This parameter limits inlining only to call expressions whose probability exceeds the given threshold (in percents).  The default value is 10.

           early-inlining-insns
               Specify growth that the early inliner can make.  In effect it increases the amount of inlining for code having a large abstraction penalty.  The default value is 10.

           max-early-inliner-iterations
           max-early-inliner-iterations
               Limit of iterations of the early inliner.  This basically bounds the number of nested indirect calls the early inliner can resolve.  Deeper chains are still handled by late inlining.

           comdat-sharing-probability
           comdat-sharing-probability
               Probability (in percent) that C++ inline function with comdat visibility are shared across multiple compilation units.  The default value is 20.

           min-vect-loop-bound
               The minimum number of iterations under which loops are not vectorized when -ftree-vectorize is used.  The number of iterations after vectorization needs to be greater than the value specified by this option to allow vectorization.  The default value is 0.

           gcse-cost-distance-ratio
               Scaling factor in calculation of maximum distance an expression can be moved by GCSE optimizations.  This is currently supported only in the code hoisting pass.  The bigger the ratio, the more aggressive code hoisting is with simple expressions, i.e., the expressions that have cost less than gcse-unrestricted-cost.  Specifying 0 disables hoisting of simple expressions.  The default value is 10.

           gcse-unrestricted-cost
               Cost, roughly measured as the cost of a single typical machine instruction, at which GCSE optimizations do not constrain the distance an expression can travel.  This is currently supported only in the code hoisting pass.  The lesser the cost, the more aggressive code hoisting is.  Specifying 0 allows all expressions to travel unrestricted distances.  The default value is 3.

           max-hoist-depth
               The depth of search in the dominator tree for expressions to hoist.  This is used to avoid quadratic behavior in hoisting algorithm.  The value of 0 does not limit on the search, but may slow down compilation of huge functions.  The default value is 30.

           max-tail-merge-comparisons
               The maximum amount of similar bbs to compare a bb with.  This is used to avoid quadratic behavior in tree tail merging.  The default value is 10.

           max-tail-merge-iterations
               The maximum amount of iterations of the pass over the function.  This is used to limit compilation time in tree tail merging.  The default value is 2.

           max-unrolled-insns
               The maximum number of instructions that a loop may have to be unrolled.  If a loop is unrolled, this parameter also determines how many times the loop code is unrolled.

           max-average-unrolled-insns
               The maximum number of instructions biased by probabilities of their execution that a loop may have to be unrolled.  If a loop is unrolled, this parameter also determines how many times the loop code is unrolled.

           max-unroll-times
               The maximum number of unrollings of a single loop.

           max-peeled-insns
               The maximum number of instructions that a loop may have to be peeled.  If a loop is peeled, this parameter also determines how many times the loop code is peeled.

           max-peel-times
               The maximum number of peelings of a single loop.

           max-peel-branches
               The maximum number of branches on the hot path through the peeled sequence.

           max-completely-peeled-insns
               The maximum number of insns of a completely peeled loop.

           max-completely-peel-times
               The maximum number of iterations of a loop to be suitable for complete peeling.

           max-completely-peel-loop-nest-depth
               The maximum depth of a loop nest suitable for complete peeling.

           max-unswitch-insns
               The maximum number of insns of an unswitched loop.

           max-unswitch-level
               The maximum number of branches unswitched in a single loop.

           lim-expensive
               The minimum cost of an expensive expression in the loop invariant motion.

           iv-consider-all-candidates-bound
               Bound on number of candidates for induction variables, below which all candidates are considered for each use in induction variable optimizations.  If there are more candidates than this, only the most relevant ones are considered to avoid quadratic time complexity.

           iv-max-considered-uses
               The induction variable optimizations give up on loops that contain more induction variable uses.

           iv-always-prune-cand-set-bound
               If the number of candidates in the set is smaller than this value, always try to remove unnecessary ivs from the set when adding a new one.

           scev-max-expr-size
               Bound on size of expressions used in the scalar evolutions analyzer.  Large expressions slow the analyzer.

           scev-max-expr-complexity
               Bound on the complexity of the expressions in the scalar evolutions analyzer.  Complex expressions slow the analyzer.

           omega-max-vars
               The maximum number of variables in an Omega constraint system.  The default value is 128.

           omega-max-geqs
               The maximum number of inequalities in an Omega constraint system.  The default value is 256.

           omega-max-eqs
               The maximum number of equalities in an Omega constraint system.  The default value is 128.

           omega-max-wild-cards
               The maximum number of wildcard variables that the Omega solver is able to insert.  The default value is 18.

           omega-hash-table-size
               The size of the hash table in the Omega solver.  The default value is 550.

           omega-max-keys
               The maximal number of keys used by the Omega solver.  The default value is 500.

           omega-eliminate-redundant-constraints
               When set to 1, use expensive methods to eliminate all redundant constraints.  The default value is 0.

           vect-max-version-for-alignment-checks
               The maximum number of run-time checks that can be performed when doing loop versioning for alignment in the vectorizer.

           vect-max-version-for-alias-checks
               The maximum number of run-time checks that can be performed when doing loop versioning for alias in the vectorizer.

           vect-max-peeling-for-alignment
               The maximum number of loop peels to enhance access alignment for vectorizer. Value -1 means 'no limit'.

           max-iterations-to-track
               The maximum number of iterations of a loop the brute-force algorithm for analysis of the number of iterations of the loop tries to evaluate.

           hot-bb-count-ws-permille
               A basic block profile count is considered hot if it contributes to the given permillage (i.e. 0...1000) of the entire profiled execution.

           hot-bb-frequency-fraction
               Select fraction of the entry block frequency of executions of basic block in function given basic block needs to have to be considered hot.

           max-predicted-iterations
               The maximum number of loop iterations we predict statically.  This is useful in cases where a function contains a single loop with known bound and another loop with unknown bound.  The known number of iterations is predicted correctly, while the unknown number of iterations average to roughly 10.  This means that the loop without bounds appears artificially cold relative to the other one.

           builtin-expect-probability
               Control the probability of the expression having the specified value. This parameter takes a percentage (i.e. 0 ... 100) as input.  The default probability of 90 is obtained empirically.

           align-threshold
               Select fraction of the maximal frequency of executions of a basic block in a function to align the basic block.

           align-loop-iterations
               A loop expected to iterate at least the selected number of iterations is aligned.

           tracer-dynamic-coverage
           tracer-dynamic-coverage-feedback
               This value is used to limit superblock formation once the given percentage of executed instructions is covered.  This limits unnecessary code size expansion.

               The tracer-dynamic-coverage-feedback is used only when profile feedback is available.  The real profiles (as opposed to statically estimated ones) are much less balanced allowing the threshold to be larger value.

           tracer-max-code-growth
               Stop tail duplication once code growth has reached given percentage.  This is a rather artificial limit, as most of the duplicates are eliminated later in cross jumping, so it may be set to much higher values than is the desired code growth.

           tracer-min-branch-ratio
               Stop reverse growth when the reverse probability of best edge is less than this threshold (in percent).

           tracer-min-branch-ratio
           tracer-min-branch-ratio-feedback
               Stop forward growth if the best edge has probability lower than this threshold.

               Similarly to tracer-dynamic-coverage two values are present, one for compilation for profile feedback and one for compilation without.  The value for compilation with profile feedback needs to be more conservative (higher) in order to make tracer effective.

           max-cse-path-length
               The maximum number of basic blocks on path that CSE considers.  The default is 10.

           max-cse-insns
               The maximum number of instructions CSE processes before flushing.  The default is 1000.

           ggc-min-expand
               GCC uses a garbage collector to manage its own memory allocation.  This parameter specifies the minimum percentage by which the garbage collector's heap should be allowed to expand between collections.  Tuning this may improve compilation speed; it has no effect on code generation.

               The default is 30% + 70% * (RAM/1GB) with an upper bound of 100% when RAM >= 1GB.  If "getrlimit" is available, the notion of "RAM" is the smallest of actual RAM and "RLIMIT_DATA" or "RLIMIT_AS".  If GCC is not able to calculate RAM on a particular platform, the lower bound of 30% is used.  Setting this parameter and ggc-min-heapsize to zero causes a full collection to occur at every opportunity.  This is extremely slow, but can be useful for debugging.

           ggc-min-heapsize
               Minimum size of the garbage collector's heap before it begins bothering to collect garbage.  The first collection occurs after the heap expands by ggc-min-expand% beyond ggc-min-heapsize.  Again, tuning this may improve compilation speed, and has no effect on code generation.

               The default is the smaller of RAM/8, RLIMIT_RSS, or a limit that tries to ensure that RLIMIT_DATA or RLIMIT_AS are not exceeded, but with a lower bound of 4096 (four megabytes) and an upper bound of 131072 (128 megabytes).  If GCC is not able to calculate RAM on a particular platform, the lower bound is used.  Setting this parameter very large effectively disables garbage collection.  Setting this parameter and ggc-min-expand to zero causes a full collection to occur at every opportunity.

           max-reload-search-insns
               The maximum number of instruction reload should look backward for equivalent register.  Increasing values mean more aggressive optimization, making the compilation time increase with probably slightly better performance.  The default value is 100.

           max-cselib-memory-locations
               The maximum number of memory locations cselib should take into account.  Increasing values mean more aggressive optimization, making the compilation time increase with probably slightly better performance.  The default value is 500.

           reorder-blocks-duplicate
           reorder-blocks-duplicate-feedback
               Used by the basic block reordering pass to decide whether to use unconditional branch or duplicate the code on its destination.  Code is duplicated when its estimated size is smaller than this value multiplied by the estimated size of unconditional jump in the hot spots of the program.

               The reorder-block-duplicate-feedback is used only when profile feedback is available.  It may be set to higher values than reorder-block-duplicate since information about the hot spots is more accurate.

           max-sched-ready-insns
               The maximum number of instructions ready to be issued the scheduler should consider at any given time during the first scheduling pass.  Increasing values mean more thorough searches, making the compilation time increase with probably little benefit.  The default value is 100.

           max-sched-region-blocks
               The maximum number of blocks in a region to be considered for interblock scheduling.  The default value is 10.

           max-pipeline-region-blocks
               The maximum number of blocks in a region to be considered for pipelining in the selective scheduler.  The default value is 15.

           max-sched-region-insns
               The maximum number of insns in a region to be considered for interblock scheduling.  The default value is 100.

           max-pipeline-region-insns
               The maximum number of insns in a region to be considered for pipelining in the selective scheduler.  The default value is 200.

           min-spec-prob
               The minimum probability (in percents) of reaching a source block for interblock speculative scheduling.  The default value is 40.

           max-sched-extend-regions-iters
               The maximum number of iterations through CFG to extend regions.  A value of 0 (the default) disables region extensions.

           max-sched-insn-conflict-delay
               The maximum conflict delay for an insn to be considered for speculative motion.  The default value is 3.

           sched-spec-prob-cutoff
               The minimal probability of speculation success (in percents), so that speculative insns are scheduled.  The default value is 40.

           sched-spec-state-edge-prob-cutoff
               The minimum probability an edge must have for the scheduler to save its state across it.  The default value is 10.

           sched-mem-true-dep-cost
               Minimal distance (in CPU cycles) between store and load targeting same memory locations.  The default value is 1.

           selsched-max-lookahead
               The maximum size of the lookahead window of selective scheduling.  It is a depth of search for available instructions.  The default value is 50.

           selsched-max-sched-times
               The maximum number of times that an instruction is scheduled during selective scheduling.  This is the limit on the number of iterations through which the instruction may be pipelined.  The default value is 2.

           selsched-max-insns-to-rename
               The maximum number of best instructions in the ready list that are considered for renaming in the selective scheduler.  The default value is 2.

           sms-min-sc
               The minimum value of stage count that swing modulo scheduler generates.  The default value is 2.

           max-last-value-rtl
               The maximum size measured as number of RTLs that can be recorded in an expression in combiner for a pseudo register as last known value of that register.  The default is 10000.

           integer-share-limit
               Small integer constants can use a shared data structure, reducing the compiler's memory usage and increasing its speed.  This sets the maximum value of a shared integer constant.  The default value is 256.

           ssp-buffer-size
               The minimum size of buffers (i.e. arrays) that receive stack smashing protection when -fstack-protection is used.

               This default before Ubuntu 10.10 was "8". Currently it is "4", to increase the number of functions protected by the stack protector.

           min-size-for-stack-sharing
               The minimum size of variables taking part in stack slot sharing when not optimizing. The default value is 32.

           max-jump-thread-duplication-stmts
               Maximum number of statements allowed in a block that needs to be duplicated when threading jumps.

           max-fields-for-field-sensitive
               Maximum number of fields in a structure treated in a field sensitive manner during pointer analysis.  The default is zero for -O0 and -O1, and 100 for -Os, -O2, and -O3.

           prefetch-latency
               Estimate on average number of instructions that are executed before prefetch finishes.  The distance prefetched ahead is proportional to this constant.  Increasing this number may also lead to less streams being prefetched (see simultaneous-prefetches).

           simultaneous-prefetches
               Maximum number of prefetches that can run at the same time.

           l1-cache-line-size
               The size of cache line in L1 cache, in bytes.

           l1-cache-size
               The size of L1 cache, in kilobytes.

           l2-cache-size
               The size of L2 cache, in kilobytes.

           min-insn-to-prefetch-ratio
               The minimum ratio between the number of instructions and the number of prefetches to enable prefetching in a loop.

           prefetch-min-insn-to-mem-ratio
               The minimum ratio between the number of instructions and the number of memory references to enable prefetching in a loop.

           use-canonical-types
               Whether the compiler should use the "canonical" type system.  By default, this should always be 1, which uses a more efficient internal mechanism for comparing types in C++ and Objective-C++.  However, if bugs in the canonical type system are causing compilation failures, set this value to 0 to disable canonical types.

           switch-conversion-max-branch-ratio
               Switch initialization conversion refuses to create arrays that are bigger than switch-conversion-max-branch-ratio times the number of branches in the switch.

           max-partial-antic-length
               Maximum length of the partial antic set computed during the tree partial redundancy elimination optimization (-ftree-pre) when optimizing at -O3 and above.  For some sorts of source code the enhanced partial redundancy elimination optimization can run away, consuming all of the memory available on the host machine.  This parameter sets a limit on the length of the sets that are computed, which prevents the runaway behavior.  Setting a value of 0 for this parameter allows an unlimited set length.

           sccvn-max-scc-size
               Maximum size of a strongly connected component (SCC) during SCCVN processing.  If this limit is hit, SCCVN processing for the whole function is not done and optimizations depending on it are disabled.  The default maximum SCC size is 10000.

           sccvn-max-alias-queries-per-access
               Maximum number of alias-oracle queries we perform when looking for redundancies for loads and stores.  If this limit is hit the search is aborted and the load or store is not considered redundant.  The number of queries is algorithmically limited to the number of stores on all paths from the load to the function entry.  The default maxmimum number of queries is 1000.

           ira-max-loops-num
               IRA uses regional register allocation by default.  If a function contains more loops than the number given by this parameter, only at most the given number of the most frequently-executed loops form regions for regional register allocation.  The default value of the parameter is 100.

           ira-max-conflict-table-size
               Although IRA uses a sophisticated algorithm to compress the conflict table, the table can still require excessive amounts of memory for huge functions.  If the conflict table for a function could be more than the size in MB given by this parameter, the register allocator instead uses a faster, simpler, and lower-quality algorithm that does not require building a pseudo-register conflict table.  The default value of the parameter is 2000.

           ira-loop-reserved-regs
               IRA can be used to evaluate more accurate register pressure in loops for decisions to move loop invariants (see -O3).  The number of available registers reserved for some other purposes is given by this parameter.  The default value of the parameter is 2, which is the minimal number of registers needed by typical instructions.  This value is the best found from numerous experiments.

           loop-invariant-max-bbs-in-loop
               Loop invariant motion can be very expensive, both in compilation time and in amount of needed compile-time memory, with very large loops.  Loops with more basic blocks than this parameter won't have loop invariant motion optimization performed on them.  The default value of the parameter is 1000 for -O1 and 10000 for -O2 and above.

           loop-max-datarefs-for-datadeps
               Building data dapendencies is expensive for very large loops.  This parameter limits the number of data references in loops that are considered for data dependence analysis.  These large loops are no handled by the optimizations using loop data dependencies.  The default value is 1000.

           max-vartrack-size
               Sets a maximum number of hash table slots to use during variable tracking dataflow analysis of any function.  If this limit is exceeded with variable tracking at assignments enabled, analysis for that function is retried without it, after removing all debug insns from the function.  If the limit is exceeded even without debug insns, var tracking analysis is completely disabled for the function.  Setting the parameter to zero makes it unlimited.

           max-vartrack-expr-depth
               Sets a maximum number of recursion levels when attempting to map variable names or debug temporaries to value expressions.  This trades compilation time for more complete debug information.  If this is set too low, value expressions that are available and could be represented in debug information may end up not being used; setting this higher may enable the compiler to find more complex debug expressions, but compile time and memory use may grow.  The default is 12.

           min-nondebug-insn-uid
               Use uids starting at this parameter for nondebug insns.  The range below the parameter is reserved exclusively for debug insns created by -fvar-tracking-assignments, but debug insns may get (non-overlapping) uids above it if the reserved range is exhausted.

           ipa-sra-ptr-growth-factor
               IPA-SRA replaces a pointer to an aggregate with one or more new parameters only when their cumulative size is less or equal to ipa-sra-ptr-growth-factor times the size of the original pointer parameter.

           tm-max-aggregate-size
               When making copies of thread-local variables in a transaction, this parameter specifies the size in bytes after which variables are saved with the logging functions as opposed to save/restore code sequence pairs.  This option only applies when using -fgnu-tm.

           graphite-max-nb-scop-params
               To avoid exponential effects in the Graphite loop transforms, the number of parameters in a Static Control Part (SCoP) is bounded.  The default value is 10 parameters.  A variable whose value is unknown at compilation time and defined outside a SCoP is a parameter of the SCoP.

           graphite-max-bbs-per-function
               To avoid exponential effects in the detection of SCoPs, the size of the functions analyzed by Graphite is bounded.  The default value is 100 basic blocks.

           loop-block-tile-size
               Loop blocking or strip mining transforms, enabled with -floop-block or -floop-strip-mine, strip mine each loop in the loop nest by a given number of iterations.  The strip length can be changed using the loop-block-tile-size parameter.  The default value is 51 iterations.

           ipa-cp-value-list-size
               IPA-CP attempts to track all possible values and types passed to a function's parameter in order to propagate them and perform devirtualization.  ipa-cp-value-list-size is the maximum number of values and types it stores per one formal parameter of a function.

           ipa-cp-eval-threshold
               IPA-CP calculates its own score of cloning profitability heuristics and performs those cloning opportunities with scores that exceed ipa-cp-eval-threshold.

           ipa-max-agg-items
               IPA-CP is also capable to propagate a number of scalar values passed in an aggregate. ipa-max-agg-items controls the maximum number of such values per one parameter.

           ipa-cp-loop-hint-bonus
               When IPA-CP determines that a cloning candidate would make the number of iterations of a loop known, it adds a bonus of ipa-cp-loop-hint-bonus bonus to the profitability score of the candidate.

           ipa-cp-array-index-hint-bonus
               When IPA-CP determines that a cloning candidate would make the index of an array access known, it adds a bonus of ipa-cp-array-index-hint-bonus bonus to the profitability score of the candidate.

           lto-partitions
               Specify desired number of partitions produced during WHOPR compilation.  The number of partitions should exceed the number of CPUs used for compilation.  The default value is 32.

           lto-minpartition
               Size of minimal partition for WHOPR (in estimated instructions).  This prevents expenses of splitting very small programs into too many partitions.

           cxx-max-namespaces-for-diagnostic-help
               The maximum number of namespaces to consult for suggestions when C++ name lookup fails for an identifier.  The default is 1000.

           sink-frequency-threshold
               The maximum relative execution frequency (in percents) of the target block relative to a statement's original block to allow statement sinking of a statement.  Larger numbers result in more aggressive statement sinking.  The default value is 75.  A small positive adjustment is applied for statements with memory operands as those are even more profitable so sink.

           max-stores-to-sink
               The maximum number of conditional stores paires that can be sunk.  Set to 0 if either vectorization (-ftree-vectorize) or if-conversion (-ftree-loop-if-convert) is disabled.  The default is 2.

           allow-load-data-races
               Allow optimizers to introduce new data races on loads.  Set to 1 to allow, otherwise to 0.  This option is enabled by default unless implicitly set by the -fmemory-model= option.

           allow-store-data-races
               Allow optimizers to introduce new data races on stores.  Set to 1 to allow, otherwise to 0.  This option is enabled by default unless implicitly set by the -fmemory-model= option.

           allow-packed-load-data-races
               Allow optimizers to introduce new data races on packed data loads.  Set to 1 to allow, otherwise to 0.  This option is enabled by default unless implicitly set by the -fmemory-model= option.

           allow-packed-store-data-races
               Allow optimizers to introduce new data races on packed data stores.  Set to 1 to allow, otherwise to 0.  This option is enabled by default unless implicitly set by the -fmemory-model= option.

           case-values-threshold
               The smallest number of different values for which it is best to use a jump-table instead of a tree of conditional branches.  If the value is 0, use the default for the machine.  The default is 0.

           tree-reassoc-width
               Set the maximum number of instructions executed in parallel in reassociated tree. This parameter overrides target dependent heuristics used by default if has non zero value.

           sched-pressure-algorithm
               Choose between the two available implementations of -fsched-pressure.  Algorithm 1 is the original implementation and is the more likely to prevent instructions from being reordered.  Algorithm 2 was designed to be a compromise between the relatively conservative approach taken by algorithm 1 and the rather aggressive approach taken by the default scheduler.  It relies more heavily on having a regular register file and accurate register pressure classes.  See haifa-sched.c in the GCC sources for more details.

               The default choice depends on the target.

           max-slsr-cand-scan
               Set the maximum number of existing candidates that will be considered when seeking a basis for a new straight-line strength reduction candidate.

           asan-globals
               Enable buffer overflow detection for global objects.  This kind of protection is enabled by default if you are using -fsanitize=address option.  To disable global objects protection use --param asan-globals=0.

           asan-stack
               Enable buffer overflow detection for stack objects.  This kind of protection is enabled by default when using-fsanitize=address.  To disable stack protection use --param asan-stack=0 option.

           asan-instrument-reads
               Enable buffer overflow detection for memory reads.  This kind of protection is enabled by default when using -fsanitize=address.  To disable memory reads protection use --param asan-instrument-reads=0.

           asan-instrument-writes
               Enable buffer overflow detection for memory writes.  This kind of protection is enabled by default when using -fsanitize=address.  To disable memory writes protection use --param asan-instrument-writes=0 option.

           asan-memintrin
               Enable detection for built-in functions.  This kind of protection is enabled by default when using -fsanitize=address.  To disable built-in functions protection use --param asan-memintrin=0.

           asan-use-after-return
               Enable detection of use-after-return.  This kind of protection is enabled by default when using -fsanitize=address option.  To disable use-after-return detection use --param asan-use-after-return=0.

           asan-instrumentation-with-call-threshold
               If number of memory accesses in function being instrumented is greater or equal to this number, use callbacks instead of inline checks.  E.g. to disable inline code use --param asan-instrumentation-with-call-threshold=0.

   Options Controlling the Preprocessor
       These options control the C preprocessor, which is run on each C source file before actual compilation.

       If you use the -E option, nothing is done except preprocessing.  Some of these options make sense only together with -E because they cause the preprocessor output to be unsuitable for actual compilation.

       -Wp,option
           You can use -Wp,option to bypass the compiler driver and pass option directly through to the preprocessor.  If option contains commas, it is split into multiple options at the commas.  However, many options are modified, translated or interpreted by the compiler driver before being passed to the preprocessor, and -Wp forcibly bypasses this phase.  The preprocessor's direct interface is undocumented and subject to change, so whenever possible you should avoid using -Wp and let the driver handle the options instead.

       -Xpreprocessor option
           Pass option as an option to the preprocessor.  You can use this to supply system-specific preprocessor options that GCC does not recognize.

           If you want to pass an option that takes an argument, you must use -Xpreprocessor twice, once for the option and once for the argument.

       -no-integrated-cpp
           Perform preprocessing as a separate pass before compilation.  By default, GCC performs preprocessing as an integrated part of input tokenization and parsing.  If this option is provided, the appropriate language front end (cc1, cc1plus, or cc1obj for C, C++, and Objective-C, respectively) is instead invoked twice, once for preprocessing only and once for actual compilation of the preprocessed input.  This option may be useful in conjunction with the -B or -wrapper options to specify an alternate preprocessor or perform additional processing of the program source between normal preprocessing and compilation.

       -D name
           Predefine name as a macro, with definition 1.

       -D name=definition
           The contents of definition are tokenized and processed as if they appeared during translation phase three in a #define directive.  In particular, the definition will be truncated by embedded newline characters.

           If you are invoking the preprocessor from a shell or shell-like program you may need to use the shell's quoting syntax to protect characters such as spaces that have a meaning in the shell syntax.

           If you wish to define a function-like macro on the command line, write its argument list with surrounding parentheses before the equals sign (if any).  Parentheses are meaningful to most shells, so you will need to quote the option.  With sh and csh, -D'name(args...)=definition' works.

           -D and -U options are processed in the order they are given on the command line.  All -imacros file and -include file options are processed after all -D and -U options.

       -U name
           Cancel any previous definition of name, either built in or provided with a -D option.

       -undef
           Do not predefine any system-specific or GCC-specific macros.  The standard predefined macros remain defined.

       -I dir
           Add the directory dir to the list of directories to be searched for header files.  Directories named by -I are searched before the standard system include directories.  If the directory dir is a standard system include directory, the option is ignored to ensure that the default search order for system directories and the special treatment of system headers are not defeated .  If dir begins with "=", then the "=" will be replaced by the sysroot prefix; see --sysroot and -isysroot.

       -o file
           Write output to file.  This is the same as specifying file as the second non-option argument to cpp.  gcc has a different interpretation of a second non-option argument, so you must use -o to specify the output file.

       -Wall
           Turns on all optional warnings which are desirable for normal code.  At present this is -Wcomment, -Wtrigraphs, -Wmultichar and a warning about integer promotion causing a change of sign in "#if" expressions.  Note that many of the preprocessor's warnings are on by default and have no options to control them.

       -Wcomment
       -Wcomments
           Warn whenever a comment-start sequence /* appears in a /* comment, or whenever a backslash-newline appears in a // comment.  (Both forms have the same effect.)

       -Wtrigraphs
           Most trigraphs in comments cannot affect the meaning of the program.  However, a trigraph that would form an escaped newline (??/ at the end of a line) can, by changing where the comment begins or ends.  Therefore, only trigraphs that would form escaped newlines produce warnings inside a comment.

           This option is implied by -Wall.  If -Wall is not given, this option is still enabled unless trigraphs are enabled.  To get trigraph conversion without warnings, but get the other -Wall warnings, use -trigraphs -Wall -Wno-trigraphs.

       -Wtraditional
           Warn about certain constructs that behave differently in traditional and ISO C.  Also warn about ISO C constructs that have no traditional C equivalent, and problematic constructs which should be avoided.

       -Wundef
           Warn whenever an identifier which is not a macro is encountered in an #if directive, outside of defined.  Such identifiers are replaced with zero.

       -Wunused-macros
           Warn about macros defined in the main file that are unused.  A macro is used if it is expanded or tested for existence at least once.  The preprocessor will also warn if the macro has not been used at the time it is redefined or undefined.

           Built-in macros, macros defined on the command line, and macros defined in include files are not warned about.

           Note: If a macro is actually used, but only used in skipped conditional blocks, then CPP will report it as unused.  To avoid the warning in such a case, you might improve the scope of the macro's definition by, for example, moving it into the first skipped block.  Alternatively, you could provide a dummy use with something like:

                   #if defined the_macro_causing_the_warning
                   #endif

       -Wendif-labels
           Warn whenever an #else or an #endif are followed by text.  This usually happens in code of the form

                   #if FOO
                   ...
                   #else FOO
                   ...
                   #endif FOO

           The second and third "FOO" should be in comments, but often are not in older programs.  This warning is on by default.

       -Werror
           Make all warnings into hard errors.  Source code which triggers warnings will be rejected.

       -Wsystem-headers
           Issue warnings for code in system headers.  These are normally unhelpful in finding bugs in your own code, therefore suppressed.  If you are responsible for the system library, you may want to see them.

       -w  Suppress all warnings, including those which GNU CPP issues by default.

       -pedantic
           Issue all the mandatory diagnostics listed in the C standard.  Some of them are left out by default, since they trigger frequently on harmless code.

       -pedantic-errors
           Issue all the mandatory diagnostics, and make all mandatory diagnostics into errors.  This includes mandatory diagnostics that GCC issues without -pedantic but treats as warnings.

       -M  Instead of outputting the result of preprocessing, output a rule suitable for make describing the dependencies of the main source file.  The preprocessor outputs one make rule containing the object file name for that source file, a colon, and the names of all the included files, including those coming from -include or -imacros command line options.

           Unless specified explicitly (with -MT or -MQ), the object file name consists of the name of the source file with any suffix replaced with object file suffix and with any leading directory parts removed.  If there are many included files then the rule is split into several lines using \-newline.  The rule has no commands.

           This option does not suppress the preprocessor's debug output, such as -dM.  To avoid mixing such debug output with the dependency rules you should explicitly specify the dependency output file with -MF, or use an environment variable like DEPENDENCIES_OUTPUT.  Debug output will still be sent to the regular output stream as normal.

           Passing -M to the driver implies -E, and suppresses warnings with an implicit -w.

       -MM Like -M but do not mention header files that are found in system header directories, nor header files that are included, directly or indirectly, from such a header.

           This implies that the choice of angle brackets or double quotes in an #include directive does not in itself determine whether that header will appear in -MM dependency output.  This is a slight change in semantics from GCC versions 3.0 and earlier.

       -MF file
           When used with -M or -MM, specifies a file to write the dependencies to.  If no -MF switch is given the preprocessor sends the rules to the same place it would have sent preprocessed output.

           When used with the driver options -MD or -MMD, -MF overrides the default dependency output file.

       -MG In conjunction with an option such as -M requesting dependency generation, -MG assumes missing header files are generated files and adds them to the dependency list without raising an error.  The dependency filename is taken directly from the "#include" directive without prepending any path.  -MG also suppresses preprocessed output, as a missing header file renders this useless.

           This feature is used in automatic updating of makefiles.

       -MP This option instructs CPP to add a phony target for each dependency other than the main file, causing each to depend on nothing.  These dummy rules work around errors make gives if you remove header files without updating the Makefile to match.

           This is typical output:

                   test.o: test.c test.h

                   test.h:

       -MT target
           Change the target of the rule emitted by dependency generation.  By default CPP takes the name of the main input file, deletes any directory components and any file suffix such as .c, and appends the platform's usual object suffix.  The result is the target.

           An -MT option will set the target to be exactly the string you specify.  If you want multiple targets, you can specify them as a single argument to -MT, or use multiple -MT options.

           For example, -MT '$(objpfx)foo.o' might give

                   $(objpfx)foo.o: foo.c

       -MQ target
           Same as -MT, but it quotes any characters which are special to Make.  -MQ '$(objpfx)foo.o' gives

                   $$(objpfx)foo.o: foo.c

           The default target is automatically quoted, as if it were given with -MQ.

       -MD -MD is equivalent to -M -MF file, except that -E is not implied.  The driver determines file based on whether an -o option is given.  If it is, the driver uses its argument but with a suffix of .d, otherwise it takes the name of the input file, removes any directory components and suffix, and applies a .d suffix.

           If -MD is used in conjunction with -E, any -o switch is understood to specify the dependency output file, but if used without -E, each -o is understood to specify a target object file.

           Since -E is not implied, -MD can be used to generate a dependency output file as a side-effect of the compilation process.

       -MMD
           Like -MD except mention only user header files, not system header files.

       -fpch-deps
           When using precompiled headers, this flag will cause the dependency-output flags to also list the files from the precompiled header's dependencies.  If not specified only the precompiled header would be listed and not the files that were used to create it because those files are not consulted when a precompiled header is used.

       -fpch-preprocess
           This option allows use of a precompiled header together with -E.  It inserts a special "#pragma", "#pragma GCC pch_preprocess "filename"" in the output to mark the place where the precompiled header was found, and its filename.  When -fpreprocessed is in use, GCC recognizes this "#pragma" and loads the PCH.

           This option is off by default, because the resulting preprocessed output is only really suitable as input to GCC.  It is switched on by -save-temps.

           You should not write this "#pragma" in your own code, but it is safe to edit the filename if the PCH file is available in a different location.  The filename may be absolute or it may be relative to GCC's current directory.

       -x c
       -x c++
       -x objective-c
       -x assembler-with-cpp
           Specify the source language: C, C++, Objective-C, or assembly.  This has nothing to do with standards conformance or extensions; it merely selects which base syntax to expect.  If you give none of these options, cpp will deduce the language from the extension of the source file: .c, .cc, .m, or .S.  Some other common extensions for C++ and assembly are also recognized.  If cpp does not recognize the extension, it will treat the file as C; this is the most generic mode.

           Note: Previous versions of cpp accepted a -lang option which selected both the language and the standards conformance level.  This option has been removed, because it conflicts with the -l option.

       -std=standard
       -ansi
           Specify the standard to which the code should conform.  Currently CPP knows about C and C++ standards; others may be added in the future.

           standard may be one of:

           "c90"
           "c89"
           "iso9899:1990"
               The ISO C standard from 1990.  c90 is the customary shorthand for this version of the standard.

               The -ansi option is equivalent to -std=c90.

           "iso9899:199409"
               The 1990 C standard, as amended in 1994.

           "iso9899:1999"
           "c99"
           "iso9899:199x"
           "c9x"
               The revised ISO C standard, published in December 1999.  Before publication, this was known as C9X.

           "iso9899:2011"
           "c11"
           "c1x"
               The revised ISO C standard, published in December 2011.  Before publication, this was known as C1X.

           "gnu90"
           "gnu89"
               The 1990 C standard plus GNU extensions.  This is the default.

           "gnu99"
           "gnu9x"
               The 1999 C standard plus GNU extensions.

           "gnu11"
           "gnu1x"
               The 2011 C standard plus GNU extensions.

           "c++98"
               The 1998 ISO C++ standard plus amendments.

           "gnu++98"
               The same as -std=c++98 plus GNU extensions.  This is the default for C++ code.

       -I- Split the include path.  Any directories specified with -I options before -I- are searched only for headers requested with "#include "file""; they are not searched for "#include <file>".  If additional directories are specified with -I options after the -I-, those directories are searched for all #include directives.

           In addition, -I- inhibits the use of the directory of the current file directory as the first search directory for "#include "file"".  This option has been deprecated.

       -nostdinc
           Do not search the standard system directories for header files.  Only the directories you have specified with -I options (and the directory of the current file, if appropriate) are searched.

       -nostdinc++
           Do not search for header files in the C++-specific standard directories, but do still search the other standard directories.  (This option is used when building the C++ library.)

       -include file
           Process file as if "#include "file"" appeared as the first line of the primary source file.  However, the first directory searched for file is the preprocessor's working directory instead of the directory containing the main source file.  If not found there, it is searched for in the remainder of the "#include "..."" search chain as normal.

           If multiple -include options are given, the files are included in the order they appear on the command line.

       -imacros file
           Exactly like -include, except that any output produced by scanning file is thrown away.  Macros it defines remain defined.  This allows you to acquire all the macros from a header without also processing its declarations.

           All files specified by -imacros are processed before all files specified by -include.

       -idirafter dir
           Search dir for header files, but do it after all directories specified with -I and the standard system directories have been exhausted.  dir is treated as a system include directory.  If dir begins with "=", then the "=" will be replaced by the sysroot prefix; see --sysroot and -isysroot.

       -iprefix prefix
           Specify prefix as the prefix for subsequent -iwithprefix options.  If the prefix represents a directory, you should include the final /.

       -iwithprefix dir
       -iwithprefixbefore dir
           Append dir to the prefix specified previously with -iprefix, and add the resulting directory to the include search path.  -iwithprefixbefore puts it in the same place -I would; -iwithprefix puts it where -idirafter would.

       -isysroot dir
           This option is like the --sysroot option, but applies only to header files (except for Darwin targets, where it applies to both header files and libraries).  See the --sysroot option for more information.

       -imultilib dir
           Use dir as a subdirectory of the directory containing target-specific C++ headers.

       -isystem dir
           Search dir for header files, after all directories specified by -I but before the standard system directories.  Mark it as a system directory, so that it gets the same special treatment as is applied to the standard system directories.  If dir begins with "=", then the "=" will be replaced by the sysroot prefix; see --sysroot and -isysroot.

       -iquote dir
           Search dir only for header files requested with "#include "file""; they are not searched for "#include <file>", before all directories specified by -I and before the standard system directories.  If dir begins with "=", then the "=" will be replaced by the sysroot prefix; see --sysroot and -isysroot.

       -fdirectives-only
           When preprocessing, handle directives, but do not expand macros.

           The option's behavior depends on the -E and -fpreprocessed options.

           With -E, preprocessing is limited to the handling of directives such as "#define", "#ifdef", and "#error".  Other preprocessor operations, such as macro expansion and trigraph conversion are not performed.  In addition, the -dD option is implicitly enabled.

           With -fpreprocessed, predefinition of command line and most builtin macros is disabled.  Macros such as "__LINE__", which are contextually dependent, are handled normally.  This enables compilation of files previously preprocessed with "-E -fdirectives-only".

           With both -E and -fpreprocessed, the rules for -fpreprocessed take precedence.  This enables full preprocessing of files previously preprocessed with "-E -fdirectives-only".

       -fdollars-in-identifiers
           Accept $ in identifiers.

       -fextended-identifiers
           Accept universal character names in identifiers.  This option is experimental; in a future version of GCC, it will be enabled by default for C99 and C++.

       -fno-canonical-system-headers
           When preprocessing, do not shorten system header paths with canonicalization.

       -fpreprocessed
           Indicate to the preprocessor that the input file has already been preprocessed.  This suppresses things like macro expansion, trigraph conversion, escaped newline splicing, and processing of most directives.  The preprocessor still recognizes and removes comments, so that you can pass a file preprocessed with -C to the compiler without problems.  In this mode the integrated preprocessor is little more than a tokenizer for the front ends.

           -fpreprocessed is implicit if the input file has one of the extensions .i, .ii or .mi.  These are the extensions that GCC uses for preprocessed files created by -save-temps.

       -ftabstop=width
           Set the distance between tab stops.  This helps the preprocessor report correct column numbers in warnings or errors, even if tabs appear on the line.  If the value is less than 1 or greater than 100, the option is ignored.  The default is 8.

       -fdebug-cpp
           This option is only useful for debugging GCC.  When used with -E, dumps debugging information about location maps.  Every token in the output is preceded by the dump of the map its location belongs to.  The dump of the map holding the location of a token would be:

                   {"P":F</file/path>;"F":F</includer/path>;"L":<line_num>;"C":<col_num>;"S":<system_header_p>;"M":<map_address>;"E":<macro_expansion_p>,"loc":<location>}

           When used without -E, this option has no effect.

       -ftrack-macro-expansion[=level]
           Track locations of tokens across macro expansions. This allows the compiler to emit diagnostic about the current macro expansion stack when a compilation error occurs in a macro expansion. Using this option makes the preprocessor and the compiler consume more memory. The level parameter can be used to choose the level of precision of token location tracking thus decreasing the memory consumption if necessary. Value 0 of level de-activates this option just as if no -ftrack-macro-expansion was present on the command line. Value 1 tracks tokens locations in a degraded mode for the sake of minimal memory overhead. In this mode all tokens resulting from the expansion of an argument of a function-like macro have the same location. Value 2 tracks tokens locations completely. This value is the most memory hungry.  When this option is given no argument, the default parameter value is 2.

           Note that -ftrack-macro-expansion=2 is activated by default.

       -fexec-charset=charset
           Set the execution character set, used for string and character constants.  The default is UTF-8.  charset can be any encoding supported by the system's "iconv" library routine.

       -fwide-exec-charset=charset
           Set the wide execution character set, used for wide string and character constants.  The default is UTF-32 or UTF-16, whichever corresponds to the width of "wchar_t".  As with -fexec-charset, charset can be any encoding supported by the system's "iconv" library routine; however, you will have problems with encodings that do not fit exactly in "wchar_t".

       -finput-charset=charset
           Set the input character set, used for translation from the character set of the input file to the source character set used by GCC.  If the locale does not specify, or GCC cannot get this information from the locale, the default is UTF-8.  This can be overridden by either the locale or this command line option.  Currently the command line option takes precedence if there's a conflict.  charset can be any encoding supported by the system's "iconv" library routine.

       -fworking-directory
           Enable generation of linemarkers in the preprocessor output that will let the compiler know the current working directory at the time of preprocessing.  When this option is enabled, the preprocessor will emit, after the initial linemarker, a second linemarker with the current working directory followed by two slashes.  GCC will use this directory, when it's present in the preprocessed input, as the directory emitted as the current working directory in some debugging information formats.  This option is implicitly enabled if debugging information is enabled, but this can be inhibited with the negated form -fno-working-directory.  If the -P flag is present in the command line, this option has no effect, since no "#line" directives are emitted whatsoever.

       -fno-show-column
           Do not print column numbers in diagnostics.  This may be necessary if diagnostics are being scanned by a program that does not understand the column numbers, such as dejagnu.

       -A predicate=answer
           Make an assertion with the predicate predicate and answer answer.  This form is preferred to the older form -A predicate(answer), which is still supported, because it does not use shell special characters.

       -A -predicate=answer
           Cancel an assertion with the predicate predicate and answer answer.

       -dCHARS
           CHARS is a sequence of one or more of the following characters, and must not be preceded by a space.  Other characters are interpreted by the compiler proper, or reserved for future versions of GCC, and so are silently ignored.  If you specify characters whose behavior conflicts, the result is undefined.

           M   Instead of the normal output, generate a list of #define directives for all the macros defined during the execution of the preprocessor, including predefined macros.  This gives you a way of finding out what is predefined in your version of the preprocessor.  Assuming you have no file foo.h, the command

                       touch foo.h; cpp -dM foo.h

               will show all the predefined macros.

               If you use -dM without the -E option, -dM is interpreted as a synonym for -fdump-rtl-mach.

           D   Like M except in two respects: it does not include the predefined macros, and it outputs both the #define directives and the result of preprocessing.  Both kinds of output go to the standard output file.

           N   Like D, but emit only the macro names, not their expansions.

           I   Output #include directives in addition to the result of preprocessing.

           U   Like D except that only macros that are expanded, or whose definedness is tested in preprocessor directives, are output; the output is delayed until the use or test of the macro; and #undef directives are also output for macros tested but undefined at the time.

       -P  Inhibit generation of linemarkers in the output from the preprocessor.  This might be useful when running the preprocessor on something that is not C code, and will be sent to a program which might be confused by the linemarkers.

       -C  Do not discard comments.  All comments are passed through to the output file, except for comments in processed directives, which are deleted along with the directive.

           You should be prepared for side effects when using -C; it causes the preprocessor to treat comments as tokens in their own right.  For example, comments appearing at the start of what would be a directive line have the effect of turning that line into an ordinary source line, since the first token on the line is no longer a #.

       -CC Do not discard comments, including during macro expansion.  This is like -C, except that comments contained within macros are also passed through to the output file where the macro is expanded.

           In addition to the side-effects of the -C option, the -CC option causes all C++-style comments inside a macro to be converted to C-style comments.  This is to prevent later use of that macro from inadvertently commenting out the remainder of the source line.

           The -CC option is generally used to support lint comments.

       -traditional-cpp
           Try to imitate the behavior of old-fashioned C preprocessors, as opposed to ISO C preprocessors.

       -trigraphs
           Process trigraph sequences.  These are three-character sequences, all starting with ??, that are defined by ISO C to stand for single characters.  For example, ??/ stands for \, so '??/n' is a character constant for a newline.  By default, GCC ignores trigraphs, but in standard-conforming modes it converts them.  See the -std and -ansi options.

           The nine trigraphs and their replacements are

                   Trigraph:       ??(  ??)  ??<  ??>  ??=  ??/  ??'  ??!  ??-
                   Replacement:      [    ]    {    }    #    \    ^    |    ~

       -remap
           Enable special code to work around file systems which only permit very short file names, such as MS-DOS.

       --help
       --target-help
           Print text describing all the command line options instead of preprocessing anything.

       -v  Verbose mode.  Print out GNU CPP's version number at the beginning of execution, and report the final form of the include path.

       -H  Print the name of each header file used, in addition to other normal activities.  Each name is indented to show how deep in the #include stack it is.  Precompiled header files are also printed, even if they are found to be invalid; an invalid precompiled header file is printed with ...x and a valid one with ...! .

       -version
       --version
           Print out GNU CPP's version number.  With one dash, proceed to preprocess as normal.  With two dashes, exit immediately.


   Passing Options to the Assembler
       You can pass options to the assembler.

       -Wa,option
           Pass option as an option to the assembler.  If option contains commas, it is split into multiple options at the commas.

       -Xassembler option
           Pass option as an option to the assembler.  You can use this to supply system-specific assembler options that GCC does not recognize.

           If you want to pass an option that takes an argument, you must use -Xassembler twice, once for the option and once for the argument.


   Options for Linking
       These options come into play when the compiler links object files into an executable output file.  They are meaningless if the compiler is not doing a link step.

       object-file-name
           A file name that does not end in a special recognized suffix is considered to name an object file or library.  (Object files are distinguished from libraries by the linker according to the file contents.)  If linking is done, these object files are used as input to the linker.

       -c
       -S
       -E  If any of these options is used, then the linker is not run, and object file names should not be used as arguments.

       -llibrary
       -l library
           Search the library named library when linking.  (The second alternative with the library as a separate argument is only for POSIX compliance and is not recommended.)

           It makes a difference where in the command you write this option; the linker searches and processes libraries and object files in the order they are specified.  Thus, foo.o -lz bar.o searches library z after file foo.o but before bar.o.  If bar.o refers to functions in z, those functions may not be loaded.

           The linker searches a standard list of directories for the library, which is actually a file named liblibrary.a.  The linker then uses this file as if it had been specified precisely by name.

           The directories searched include several standard system directories plus any that you specify with -L.

           Normally the files found this way are library files---archive files whose members are object files.  The linker handles an archive file by scanning through it for members which define symbols that have so far been referenced but not defined.  But if the file that is found is an ordinary object file, it is linked in the usual fashion.  The only difference between using an -l option and specifying a file name is that -l surrounds library with lib and .a and searches several directories.

       -lobjc
           You need this special case of the -l option in order to link an Objective-C or Objective-C++ program.

       -nostartfiles
           Do not use the standard system startup files when linking.  The standard system libraries are used normally, unless -nostdlib or -nodefaultlibs is used.

       -nodefaultlibs
           Do not use the standard system libraries when linking.  Only the libraries you specify are passed to the linker, and options specifying linkage of the system libraries, such as "-static-libgcc" or "-shared-libgcc", are ignored.  The standard startup files are used normally, unless -nostartfiles is used.

           The compiler may generate calls to "memcmp", "memset", "memcpy" and "memmove".  These entries are usually resolved by entries in libc.  These entry points should be supplied through some other mechanism when this option is specified.

       -nostdlib
           Do not use the standard system startup files or libraries when linking.  No startup files and only the libraries you specify are passed to the linker, and options specifying linkage of the system libraries, such as "-static-libgcc" or "-shared-libgcc", are ignored.

           The compiler may generate calls to "memcmp", "memset", "memcpy" and "memmove".  These entries are usually resolved by entries in libc.  These entry points should be supplied through some other mechanism when this option is specified.

           One of the standard libraries bypassed by -nostdlib and -nodefaultlibs is libgcc.a, a library of internal subroutines which GCC uses to overcome shortcomings of particular machines, or special needs for some languages.

           In most cases, you need libgcc.a even when you want to avoid other standard libraries.  In other words, when you specify -nostdlib or -nodefaultlibs you should usually specify -lgcc as well.  This ensures that you have no unresolved references to internal GCC library subroutines.  (An example of such an internal subroutine is __main, used to ensure C++ constructors are called.)

       -pie
           Produce a position independent executable on targets that support it.  For predictable results, you must also specify the same set of options used for compilation (-fpie, -fPIE, or model suboptions) when you specify this linker option.

       -rdynamic
           Pass the flag -export-dynamic to the ELF linker, on targets that support it. This instructs the linker to add all symbols, not only used ones, to the dynamic symbol table. This option is needed for some uses of "dlopen" or to allow obtaining backtraces from within a program.

       -s  Remove all symbol table and relocation information from the executable.

       -static
           On systems that support dynamic linking, this prevents linking with the shared libraries.  On other systems, this option has no effect.

       -shared
           Produce a shared object which can then be linked with other objects to form an executable.  Not all systems support this option.  For predictable results, you must also specify the same set of options used for compilation (-fpic, -fPIC, or model suboptions) when you specify this linker option.[1]

       -shared-libgcc
       -static-libgcc
           On systems that provide libgcc as a shared library, these options force the use of either the shared or static version, respectively.  If no shared version of libgcc was built when the compiler was configured, these options have no effect.

           There are several situations in which an application should use the shared libgcc instead of the static version.  The most common of these is when the application wishes to throw and catch exceptions across different shared libraries.  In that case, each of the libraries as well as the application itself should use the shared libgcc.

           Therefore, the G++ and GCJ drivers automatically add -shared-libgcc whenever you build a shared library or a main executable, because C++ and Java programs typically use exceptions, so this is the right thing to do.

           If, instead, you use the GCC driver to create shared libraries, you may find that they are not always linked with the shared libgcc.  If GCC finds, at its configuration time, that you have a non-GNU linker or a GNU linker that does not support option --eh-frame-hdr, it links the shared version of libgcc into shared libraries by default.  Otherwise, it takes advantage of the linker and optimizes away the linking with the shared version of libgcc, linking with the static version of libgcc by default.  This allows exceptions to propagate through such shared libraries, without incurring relocation costs at library load time.

           However, if a library or main executable is supposed to throw or catch exceptions, you must link it using the G++ or GCJ driver, as appropriate for the languages used in the program, or using the option -shared-libgcc, such that it is linked with the shared libgcc.

       -static-libasan
           When the -fsanitize=address option is used to link a program, the GCC driver automatically links against libasan.  If libasan is available as a shared library, and the -static option is not used, then this links against the shared version of libasan.  The -static-libasan option directs the GCC driver to link libasan statically, without necessarily linking other libraries statically.

       -static-libtsan
           When the -fsanitize=thread option is used to link a program, the GCC driver automatically links against libtsan.  If libtsan is available as a shared library, and the -static option is not used, then this links against the shared version of libtsan.  The -static-libtsan option directs the GCC driver to link libtsan statically, without necessarily linking other libraries statically.

       -static-liblsan
           When the -fsanitize=leak option is used to link a program, the GCC driver automatically links against liblsan.  If liblsan is available as a shared library, and the -static option is not used, then this links against the shared version of liblsan.  The -static-liblsan option directs the GCC driver to link liblsan statically, without necessarily linking other libraries statically.

       -static-libubsan
           When the -fsanitize=undefined option is used to link a program, the GCC driver automatically links against libubsan.  If libubsan is available as a shared library, and the -static option is not used, then this links against the shared version of libubsan.  The -static-libubsan option directs the GCC driver to link libubsan statically, without necessarily linking other libraries statically.

       -static-libstdc++
           When the g++ program is used to link a C++ program, it normally automatically links against libstdc++.  If libstdc++ is available as a shared library, and the -static option is not used, then this links against the shared version of libstdc++.  That is normally fine.  However, it is sometimes useful to freeze the version of libstdc++ used by the program without going all the way to a fully static link.  The -static-libstdc++ option directs the g++ driver to link libstdc++ statically, without necessarily linking other libraries statically.

       -symbolic
           Bind references to global symbols when building a shared object.  Warn about any unresolved references (unless overridden by the link editor option -Xlinker -z -Xlinker defs).  Only a few systems support this option.

       -T script
           Use script as the linker script.  This option is supported by most systems using the GNU linker.  On some targets, such as bare-board targets without an operating system, the -T option may be required when linking to avoid references to undefined symbols.

       -Xlinker option
           Pass option as an option to the linker.  You can use this to supply system-specific linker options that GCC does not recognize.

           If you want to pass an option that takes a separate argument, you must use -Xlinker twice, once for the option and once for the argument.  For example, to pass -assert definitions, you must write -Xlinker -assert -Xlinker definitions.  It does not work to write -Xlinker "-assert definitions", because this passes the entire string as a single argument, which is not what the linker expects.

           When using the GNU linker, it is usually more convenient to pass arguments to linker options using the option=value syntax than as separate arguments.  For example, you can specify -Xlinker -Map=output.map rather than -Xlinker -Map -Xlinker output.map.  Other linkers may not support this syntax for command-line options.

       -Wl,option
           Pass option as an option to the linker.  If option contains commas, it is split into multiple options at the commas.  You can use this syntax to pass an argument to the option.  For example, -Wl,-Map,output.map passes -Map output.map to the linker.  When using the GNU linker, you can also get the same effect with -Wl,-Map=output.map.

           NOTE: In Ubuntu 8.10 and later versions, for LDFLAGS, the option -Wl,-z,relro is used.  To disable, use -Wl,-z,norelro.

       -u symbol
           Pretend the symbol symbol is undefined, to force linking of library modules to define it.  You can use -u multiple times with different symbols to force loading of additional library modules.

   Options for Directory Search
       These options specify directories to search for header files, for libraries and for parts of the compiler:

       -Idir
           Add the directory dir to the head of the list of directories to be searched for header files.  This can be used to override a system header file, substituting your own version, since these directories are searched before the system header file directories.  However, you should not use this option to add directories that contain vendor-supplied system header files (use -isystem for that).  If you use more than one -I option, the directories are scanned in left-to-right order; the standard system directories come after.

           If a standard system include directory, or a directory specified with -isystem, is also specified with -I, the -I option is ignored.  The directory is still searched but as a system directory at its normal position in the system include chain.  This is to ensure that GCC's procedure to fix buggy system headers and the ordering for the "include_next" directive are not inadvertently changed.  If you really need to change the search order for system directories, use the -nostdinc and/or -isystem options.

       -iplugindir=dir
           Set the directory to search for plugins that are passed by -fplugin=name instead of -fplugin=path/name.so.  This option is not meant to be used by the user, but only passed by the driver.

       -iquotedir
           Add the directory dir to the head of the list of directories to be searched for header files only for the case of #include "file"; they are not searched for #include <file>, otherwise just like -I.

       -Ldir
           Add directory dir to the list of directories to be searched for -l.

       -Bprefix
           This option specifies where to find the executables, libraries, include files, and data files of the compiler itself.

           The compiler driver program runs one or more of the subprograms cpp, cc1, as and ld.  It tries prefix as a prefix for each program it tries to run, both with and without machine/version/.

           For each subprogram to be run, the compiler driver first tries the -B prefix, if any.  If that name is not found, or if -B is not specified, the driver tries two standard prefixes, /usr/lib/gcc/ and /usr/local/lib/gcc/.  If neither of those results in a file name that is found, the unmodified program name is searched for using the directories specified in your PATH environment variable.

           The compiler checks to see if the path provided by the -B refers to a directory, and if necessary it adds a directory separator character at the end of the path.

           -B prefixes that effectively specify directory names also apply to libraries in the linker, because the compiler translates these options into -L options for the linker.  They also apply to include files in the preprocessor, because the compiler translates these options into -isystem options for the preprocessor.  In this case, the compiler appends include to the prefix.

           The runtime support file libgcc.a can also be searched for using the -B prefix, if needed.  If it is not found there, the two standard prefixes above are tried, and that is all.  The file is left out of the link if it is not found by those means.

           Another way to specify a prefix much like the -B prefix is to use the environment variable GCC_EXEC_PREFIX.

           As a special kludge, if the path provided by -B is [dir/]stageN/, where N is a number in the range 0 to 9, then it is replaced by [dir/]include.  This is to help with boot-strapping the compiler.

       -specs=file
           Process file after the compiler reads in the standard specs file, in order to override the defaults which the gcc driver program uses when determining what switches to pass to cc1, cc1plus, as, ld, etc.  More than one -specs=file can be specified on the command line, and they are processed in order, from left to right.

       --sysroot=dir
           Use dir as the logical root directory for headers and libraries.  For example, if the compiler normally searches for headers in /usr/include and libraries in /usr/lib, it instead searches dir/usr/include and dir/usr/lib.

           If you use both this option and the -isysroot option, then the --sysroot option applies to libraries, but the -isysroot option applies to header files.

           The GNU linker (beginning with version 2.16) has the necessary support for this option.  If your linker does not support this option, the header file aspect of --sysroot still works, but the library aspect does not.

       --no-sysroot-suffix
           For some targets, a suffix is added to the root directory specified with --sysroot, depending on the other options used, so that headers may for example be found in dir/suffix/usr/include instead of dir/usr/include.  This option disables the addition of such a suffix.

       -I- This option has been deprecated.  Please use -iquote instead for -I directories before the -I- and remove the -I-.  Any directories you specify with -I options before the -I- option are searched only for the case of #include "file"; they are not searched for #include <file>.

           If additional directories are specified with -I options after the -I-, these directories are searched for all #include directives.  (Ordinarily all -I directories are used this way.)

           In addition, the -I- option inhibits the use of the current directory (where the current input file came from) as the first search directory for #include "file".  There is no way to override this effect of -I-.  With -I. you can specify searching the directory that is current when the compiler is invoked.  That is not exactly the same as what the preprocessor does by default, but it is often satisfactory.

           -I- does not inhibit the use of the standard system directories for header files.  Thus, -I- and -nostdinc are independent.

   Specifying Target Machine and Compiler Version
       The usual way to run GCC is to run the executable called gcc, or machine-gcc when cross-compiling, or machine-gcc-version to run a version other than the one that was installed last.

   Hardware Models and Configurations
       Each target machine types can have its own special options, starting with -m, to choose among various hardware models or configurations---for example, 68010 vs 68020, floating coprocessor or none.  A single installed version of the compiler can compile for any model or configuration, according to the options specified.

       Some configurations of the compiler also support additional special options, usually for compatibility with other compilers on the same platform.


       Intel 386 and AMD x86-64 Options

       These -m options are defined for the i386 and x86-64 family of computers:

       -march=cpu-type
           Generate instructions for the machine type cpu-type.  In contrast to -mtune=cpu-type, which merely tunes the generated code for the specified cpu-type, -march=cpu-type allows GCC to generate code that may not run at all on processors other than the one indicated.  Specifying -march=cpu-type implies -mtune=cpu-type.

           The choices for cpu-type are:

           native
               This selects the CPU to generate code for at compilation time by determining the processor type of the compiling machine.  Using -march=native enables all instruction subsets supported by the local machine (hence the result might not run on different machines).  Using -mtune=native produces code optimized for the local machine under the constraints of the selected instruction set.

           i386
               Original Intel i386 CPU.

           i486
               Intel i486 CPU.  (No scheduling is implemented for this chip.)

           i586
           pentium
               Intel Pentium CPU with no MMX support.

           pentium-mmx
               Intel Pentium MMX CPU, based on Pentium core with MMX instruction set support.

           pentiumpro
               Intel Pentium Pro CPU.

           i686
               When used with -march, the Pentium Pro instruction set is used, so the code runs on all i686 family chips.  When used with -mtune, it has the same meaning as generic.

           pentium2
               Intel Pentium II CPU, based on Pentium Pro core with MMX instruction set support.

           pentium3
           pentium3m
               Intel Pentium III CPU, based on Pentium Pro core with MMX and SSE instruction set support.

           pentium-m
               Intel Pentium M; low-power version of Intel Pentium III CPU with MMX, SSE and SSE2 instruction set support.  Used by Centrino notebooks.

           pentium4
           pentium4m
               Intel Pentium 4 CPU with MMX, SSE and SSE2 instruction set support.

           prescott
               Improved version of Intel Pentium 4 CPU with MMX, SSE, SSE2 and SSE3 instruction set support.

           nocona
               Improved version of Intel Pentium 4 CPU with 64-bit extensions, MMX, SSE, SSE2 and SSE3 instruction set support.

           core2
               Intel Core 2 CPU with 64-bit extensions, MMX, SSE, SSE2, SSE3 and SSSE3 instruction set support.

           nehalem
               Intel Nehalem CPU with 64-bit extensions, MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2 and POPCNT instruction set support.

           westmere
               Intel Westmere CPU with 64-bit extensions, MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, POPCNT, AES and PCLMUL instruction set support.

           sandybridge
               Intel Sandy Bridge CPU with 64-bit extensions, MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, POPCNT, AVX, AES and PCLMUL instruction set support.

           ivybridge
               Intel Ivy Bridge CPU with 64-bit extensions, MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, POPCNT, AVX, AES, PCLMUL, FSGSBASE, RDRND and F16C instruction set support.

           haswell
               Intel Haswell CPU with 64-bit extensions, MOVBE, MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, POPCNT, AVX, AVX2, AES, PCLMUL, FSGSBASE, RDRND, FMA, BMI, BMI2 and F16C instruction set support.

           broadwell
               Intel Broadwell CPU with 64-bit extensions, MOVBE, MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, POPCNT, AVX, AVX2, AES, PCLMUL, FSGSBASE, RDRND, FMA, BMI, BMI2, F16C, RDSEED, ADCX and PREFETCHW instruction set support.

           bonnell
               Intel Bonnell CPU with 64-bit extensions, MOVBE, MMX, SSE, SSE2, SSE3 and SSSE3 instruction set support.

           silvermont
               Intel Silvermont CPU with 64-bit extensions, MOVBE, MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, POPCNT, AES, PCLMUL and RDRND instruction set support.

           k6  AMD K6 CPU with MMX instruction set support.

           k6-2
           k6-3
               Improved versions of AMD K6 CPU with MMX and 3DNow! instruction set support.

           athlon
           athlon-tbird
               AMD Athlon CPU with MMX, 3dNOW!, enhanced 3DNow! and SSE prefetch instructions support.

           athlon-4
           athlon-xp
           athlon-mp
               Improved AMD Athlon CPU with MMX, 3DNow!, enhanced 3DNow! and full SSE instruction set support.

           k8
           opteron
           athlon64
           athlon-fx
               Processors based on the AMD K8 core with x86-64 instruction set support, including the AMD Opteron, Athlon 64, and Athlon 64 FX processors.  (This supersets MMX, SSE, SSE2, 3DNow!, enhanced 3DNow! and 64-bit instruction set extensions.)

           k8-sse3
           opteron-sse3
           athlon64-sse3
               Improved versions of AMD K8 cores with SSE3 instruction set support.

           amdfam10
           barcelona
               CPUs based on AMD Family 10h cores with x86-64 instruction set support.  (This supersets MMX, SSE, SSE2, SSE3, SSE4A, 3DNow!, enhanced 3DNow!, ABM and 64-bit instruction set extensions.)

           bdver1
               CPUs based on AMD Family 15h cores with x86-64 instruction set support.  (This supersets FMA4, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)

           bdver2
               AMD Family 15h core based CPUs with x86-64 instruction set support.  (This supersets BMI, TBM, F16C, FMA, FMA4, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)

           bdver3
               AMD Family 15h core based CPUs with x86-64 instruction set support.  (This supersets BMI, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.

           bdver4
               AMD Family 15h core based CPUs with x86-64 instruction set support.  (This supersets BMI, BMI2, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, AVX2, XOP, LWP, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.

           btver1
               CPUs based on AMD Family 14h cores with x86-64 instruction set support.  (This supersets MMX, SSE, SSE2, SSE3, SSSE3, SSE4A, CX16, ABM and 64-bit instruction set extensions.)

           btver2
               CPUs based on AMD Family 16h cores with x86-64 instruction set support. This includes MOVBE, F16C, BMI, AVX, PCL_MUL, AES, SSE4.2, SSE4.1, CX16, ABM, SSE4A, SSSE3, SSE3, SSE2, SSE, MMX and 64-bit instruction set extensions.

           winchip-c6
               IDT WinChip C6 CPU, dealt in same way as i486 with additional MMX instruction set support.

           winchip2
               IDT WinChip 2 CPU, dealt in same way as i486 with additional MMX and 3DNow!  instruction set support.

           c3  VIA C3 CPU with MMX and 3DNow! instruction set support.  (No scheduling is implemented for this chip.)

           c3-2
               VIA C3-2 (Nehemiah/C5XL) CPU with MMX and SSE instruction set support.  (No scheduling is implemented for this chip.)

           geode
               AMD Geode embedded processor with MMX and 3DNow! instruction set support.

       -mtune=cpu-type
           Tune to cpu-type everything applicable about the generated code, except for the ABI and the set of available instructions.  While picking a specific cpu-type schedules things appropriately for that particular chip, the compiler does not generate any code that cannot run on the default machine type unless you use a -march=cpu-type option.  For example, if GCC is configured for i686-pc-linux-gnu then -mtune=pentium4 generates code that is tuned for Pentium 4 but still runs on i686 machines.

           The choices for cpu-type are the same as for -march.  In addition, -mtune supports 2 extra choices for cpu-type:

           generic
               Produce code optimized for the most common IA32/AMD64/EM64T processors.  If you know the CPU on which your code will run, then you should use the corresponding -mtune or -march option instead of -mtune=generic.  But, if you do not know exactly what CPU users of your application will have, then you should use this option.

               As new processors are deployed in the marketplace, the behavior of this option will change.  Therefore, if you upgrade to a newer version of GCC, code generation controlled by this option will change to reflect the processors that are most common at the time that version of GCC is released.

               There is no -march=generic option because -march indicates the instruction set the compiler can use, and there is no generic instruction set applicable to all processors.  In contrast, -mtune indicates the processor (or, in this case, collection of processors) for which the code is optimized.

           intel
               Produce code optimized for the most current Intel processors, which are Haswell and Silvermont for this version of GCC.  If you know the CPU on which your code will run, then you should use the corresponding -mtune or -march option instead of -mtune=intel.  But, if you want your application performs better on both Haswell and Silvermont, then you should use this option.

               As new Intel processors are deployed in the marketplace, the behavior of this option will change.  Therefore, if you upgrade to a newer version of GCC, code generation controlled by this option will change to reflect the most current Intel processors at the time that version of GCC is released.

               There is no -march=intel option because -march indicates the instruction set the compiler can use, and there is no common instruction set applicable to all processors.  In contrast, -mtune indicates the processor (or, in this case, collection of processors) for which the code is optimized.

       -mcpu=cpu-type
           A deprecated synonym for -mtune.

       -mfpmath=unit
           Generate floating-point arithmetic for selected unit unit.  The choices for unit are:

           387 Use the standard 387 floating-point coprocessor present on the majority of chips and emulated otherwise.  Code compiled with this option runs almost everywhere.  The temporary results are computed in 80-bit precision instead of the precision specified by the type, resulting in slightly different results compared to most of other chips.  See -ffloat-store for more detailed description.

               This is the default choice for i386 compiler.

           sse Use scalar floating-point instructions present in the SSE instruction set.  This instruction set is supported by Pentium III and newer chips, and in the AMD line by Athlon-4, Athlon XP and Athlon MP chips.  The earlier version of the SSE instruction set supports only single-precision arithmetic, thus the double and extended-precision arithmetic are still done using 387.  A later version, present only in Pentium 4 and AMD x86-64 chips, supports double-precision arithmetic too.

               For the i386 compiler, you must use -march=cpu-type, -msse or -msse2 switches to enable SSE extensions and make this option effective.  For the x86-64 compiler, these extensions are enabled by default.

               The resulting code should be considerably faster in the majority of cases and avoid the numerical instability problems of 387 code, but may break some existing code that expects temporaries to be 80 bits.

               This is the default choice for the x86-64 compiler.

           sse,387
           sse+387
           both
               Attempt to utilize both instruction sets at once.  This effectively doubles the amount of available registers, and on chips with separate execution units for 387 and SSE the execution resources too.  Use this option with care, as it is still experimental, because the GCC register allocator does not model separate functional units well, resulting in unstable performance.

       -masm=dialect
           Output assembly instructions using selected dialect.  Supported choices are intel or att (the default).  Darwin does not support intel.

       -mieee-fp
       -mno-ieee-fp
           Control whether or not the compiler uses IEEE floating-point comparisons.  These correctly handle the case where the result of a comparison is unordered.

       -msoft-float
           Generate output containing library calls for floating point.

           Warning: the requisite libraries are not part of GCC.  Normally the facilities of the machine's usual C compiler are used, but this can't be done directly in cross-compilation.  You must make your own arrangements to provide suitable library functions for cross-compilation.

           On machines where a function returns floating-point results in the 80387 register stack, some floating-point opcodes may be emitted even if -msoft-float is used.

       -mno-fp-ret-in-387
           Do not use the FPU registers for return values of functions.

           The usual calling convention has functions return values of types "float" and "double" in an FPU register, even if there is no FPU.  The idea is that the operating system should emulate an FPU.

           The option -mno-fp-ret-in-387 causes such values to be returned in ordinary CPU registers instead.

       -mno-fancy-math-387
           Some 387 emulators do not support the "sin", "cos" and "sqrt" instructions for the 387.  Specify this option to avoid generating those instructions.  This option is the default on FreeBSD, OpenBSD and NetBSD.  This option is overridden when -march indicates that the target CPU always has an FPU and so the instruction does not need emulation.  These instructions are not generated unless you also use the -funsafe-math-optimizations switch.

       -malign-double
       -mno-align-double
           Control whether GCC aligns "double", "long double", and "long long" variables on a two-word boundary or a one-word boundary.  Aligning "double" variables on a two-word boundary produces code that runs somewhat faster on a Pentium at the expense of more memory.

           On x86-64, -malign-double is enabled by default.

           Warning: if you use the -malign-double switch, structures containing the above types are aligned differently than the published application binary interface specifications for the 386 and are not binary compatible with structures in code compiled without that switch.

       -m96bit-long-double
       -m128bit-long-double
           These switches control the size of "long double" type.  The i386 application binary interface specifies the size to be 96 bits, so -m96bit-long-double is the default in 32-bit mode.

           Modern architectures (Pentium and newer) prefer "long double" to be aligned to an 8- or 16-byte boundary.  In arrays or structures conforming to the ABI, this is not possible.  So specifying -m128bit-long-double aligns "long double" to a 16-byte boundary by padding the "long double" with an additional 32-bit zero.

           In the x86-64 compiler, -m128bit-long-double is the default choice as its ABI specifies that "long double" is aligned on 16-byte boundary.

           Notice that neither of these options enable any extra precision over the x87 standard of 80 bits for a "long double".

           Warning: if you override the default value for your target ABI, this changes the size of structures and arrays containing "long double" variables, as well as modifying the function calling convention for functions taking "long double".  Hence they are not binary-compatible with code compiled without that switch.

       -mlong-double-64
       -mlong-double-80
       -mlong-double-128
           These switches control the size of "long double" type. A size of 64 bits makes the "long double" type equivalent to the "double" type. This is the default for 32-bit Bionic C library.  A size of 128 bits makes the "long double" type equivalent to the "__float128" type. This is the default for 64-bit Bionic C library.

           Warning: if you override the default value for your target ABI, this changes the size of structures and arrays containing "long double" variables, as well as modifying the function calling convention for functions taking "long double".  Hence they are not binary-compatible with code compiled without that switch.

       -mlarge-data-threshold=threshold
           When -mcmodel=medium is specified, data objects larger than threshold are placed in the large data section.  This value must be the same across all objects linked into the binary, and defaults to 65535.

       -mrtd
           Use a different function-calling convention, in which functions that take a fixed number of arguments return with the "ret num" instruction, which pops their arguments while returning.  This saves one instruction in the caller since there is no need to pop the arguments there.

           You can specify that an individual function is called with this calling sequence with the function attribute stdcall.  You can also override the -mrtd option by using the function attribute cdecl.

           Warning: this calling convention is incompatible with the one normally used on Unix, so you cannot use it if you need to call libraries compiled with the Unix compiler.

           Also, you must provide function prototypes for all functions that take variable numbers of arguments (including "printf"); otherwise incorrect code is generated for calls to those functions.

           In addition, seriously incorrect code results if you call a function with too many arguments.  (Normally, extra arguments are harmlessly ignored.)

       -mregparm=num
           Control how many registers are used to pass integer arguments.  By default, no registers are used to pass arguments, and at most 3 registers can be used.  You can control this behavior for a specific function by using the function attribute regparm.

           Warning: if you use this switch, and num is nonzero, then you must build all modules with the same value, including any libraries.  This includes the system libraries and startup modules.

       -msseregparm
           Use SSE register passing conventions for float and double arguments and return values.  You can control this behavior for a specific function by using the function attribute sseregparm.

           Warning: if you use this switch then you must build all modules with the same value, including any libraries.  This includes the system libraries and startup modules.

       -mvect8-ret-in-mem
           Return 8-byte vectors in memory instead of MMX registers.  This is the default on Solaris@tie{}8 and 9 and VxWorks to match the ABI of the Sun Studio compilers until version 12.  Later compiler versions (starting with Studio 12 Update@tie{}1) follow the ABI used by other x86 targets, which is the default on Solaris@tie{}10 and later.  Only use this option if you need to remain compatible with existing code produced by those previous compiler versions or older versions of GCC.

       -mpc32
       -mpc64
       -mpc80
           Set 80387 floating-point precision to 32, 64 or 80 bits.  When -mpc32 is specified, the significands of results of floating-point operations are rounded to 24 bits (single precision); -mpc64 rounds the significands of results of floating-point operations to 53 bits (double precision) and -mpc80 rounds the significands of results of floating-point operations to 64 bits (extended double precision), which is the default.  When this option is used, floating-point operations in higher precisions are not available to the programmer without setting the FPU control word explicitly.

           Setting the rounding of floating-point operations to less than the default 80 bits can speed some programs by 2% or more.  Note that some mathematical libraries assume that extended-precision (80-bit) floating-point operations are enabled by default; routines in such libraries could suffer significant loss of accuracy, typically through so-called "catastrophic cancellation", when this option is used to set the precision to less than extended precision.

       -mstackrealign
           Realign the stack at entry.  On the Intel x86, the -mstackrealign option generates an alternate prologue and epilogue that realigns the run-time stack if necessary.  This supports mixing legacy codes that keep 4-byte stack alignment with modern codes that keep 16-byte stack alignment for SSE compatibility.  See also the attribute "force_align_arg_pointer", applicable to individual functions.

       -mpreferred-stack-boundary=num
           Attempt to keep the stack boundary aligned to a 2 raised to num byte boundary.  If -mpreferred-stack-boundary is not specified, the default is 4 (16 bytes or 128 bits).

           Warning: When generating code for the x86-64 architecture with SSE extensions disabled, -mpreferred-stack-boundary=3 can be used to keep the stack boundary aligned to 8 byte boundary.  Since x86-64 ABI require 16 byte stack alignment, this is ABI incompatible and intended to be used in controlled environment where stack space is important limitation.  This option will lead to wrong code when functions compiled with 16 byte stack alignment (such as functions from a standard library) are called with misaligned stack.  In this case, SSE instructions may lead to misaligned memory access traps.  In addition, variable arguments will be handled incorrectly for 16 byte aligned objects (including x87 long double and __int128), leading to wrong results.  You must build all modules with -mpreferred-stack-boundary=3, including any libraries.  This includes the system libraries and startup modules.

       -mincoming-stack-boundary=num
           Assume the incoming stack is aligned to a 2 raised to num byte boundary.  If -mincoming-stack-boundary is not specified, the one specified by -mpreferred-stack-boundary is used.

           On Pentium and Pentium Pro, "double" and "long double" values should be aligned to an 8-byte boundary (see -malign-double) or suffer significant run time performance penalties.  On Pentium III, the Streaming SIMD Extension (SSE) data type "__m128" may not work properly if it is not 16-byte aligned.

           To ensure proper alignment of this values on the stack, the stack boundary must be as aligned as that required by any value stored on the stack.  Further, every function must be generated such that it keeps the stack aligned.  Thus calling a function compiled with a higher preferred stack boundary from a function compiled with a lower preferred stack boundary most likely misaligns the stack.  It is recommended that libraries that use callbacks always use the default setting.

           This extra alignment does consume extra stack space, and generally increases code size.  Code that is sensitive to stack space usage, such as embedded systems and operating system kernels, may want to reduce the preferred alignment to -mpreferred-stack-boundary=2.

       -mmmx
       -mno-mmx
       -msse
       -mno-sse
       -msse2
       -mno-sse2
       -msse3
       -mno-sse3
       -mssse3
       -mno-ssse3
       -msse4.1
       -mno-sse4.1
       -msse4.2
       -mno-sse4.2
       -msse4
       -mno-sse4
       -mavx
       -mno-avx
       -mavx2
       -mno-avx2
       -mavx512f
       -mno-avx512f
       -mavx512pf
       -mno-avx512pf
       -mavx512er
       -mno-avx512er
       -mavx512cd
       -mno-avx512cd
       -msha
       -mno-sha
       -maes
       -mno-aes
       -mpclmul
       -mno-pclmul
       -mfsgsbase
       -mno-fsgsbase
       -mrdrnd
       -mno-rdrnd
       -mf16c
       -mno-f16c
       -mfma
       -mno-fma
       -mprefetchwt1
       -mno-prefetchwt1
       -msse4a
       -mno-sse4a
       -mfma4
       -mno-fma4
       -mxop
       -mno-xop
       -mlwp
       -mno-lwp
       -m3dnow
       -mno-3dnow
       -mpopcnt
       -mno-popcnt
       -mabm
       -mno-abm
       -mbmi
       -mbmi2
       -mno-bmi
       -mno-bmi2
       -mlzcnt
       -mno-lzcnt
       -mfxsr
       -mxsave
       -mxsaveopt
       -mrtm
       -mtbm
       -mno-tbm
           These switches enable or disable the use of instructions in the MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, AVX, AVX2, AVX512F, AVX512PF, AVX512ER, AVX512CD, SHA, AES, PCLMUL, FSGSBASE, RDRND, F16C, FMA, SSE4A, FMA4, XOP, LWP, ABM, BMI, BMI2, FXSR, XSAVE, XSAVEOPT, LZCNT, RTM, or 3DNow!  extended instruction sets.  These extensions are also available as built-in functions: see X86 Built-in Functions, for details of the functions enabled and disabled by these switches.

           To generate SSE/SSE2 instructions automatically from floating-point code (as opposed to 387 instructions), see -mfpmath=sse.

           GCC depresses SSEx instructions when -mavx is used. Instead, it generates new AVX instructions or AVX equivalence for all SSEx instructions when needed.

           These options enable GCC to use these extended instructions in generated code, even without -mfpmath=sse.  Applications that perform run-time CPU detection must compile separate files for each supported architecture, using the appropriate flags.  In particular, the file containing the CPU detection code should be compiled without these options.

       -mdump-tune-features
           This option instructs GCC to dump the names of the x86 performance tuning features and default settings. The names can be used in -mtune-ctrl=feature-list.

       -mtune-ctrl=feature-list
           This option is used to do fine grain control of x86 code generation features.  feature-list is a comma separated list of feature names. See also -mdump-tune-features. When specified, the feature will be turned on if it is not preceded with "^", otherwise, it will be turned off.  -mtune-ctrl=feature-list is intended to be used by GCC developers. Using it may lead to code paths not covered by testing and can potentially result in compiler ICEs or runtime errors.

       -mno-default
           This option instructs GCC to turn off all tunable features. See also -mtune-ctrl=feature-list and -mdump-tune-features.

       -mcld
           This option instructs GCC to emit a "cld" instruction in the prologue of functions that use string instructions.  String instructions depend on the DF flag to select between autoincrement or autodecrement mode.  While the ABI specifies the DF flag to be cleared on function entry, some operating systems violate this specification by not clearing the DF flag in their exception dispatchers.  The exception handler can be invoked with the DF flag set, which leads to wrong direction mode when string instructions are used.  This option can be enabled by default on 32-bit x86 targets by configuring GCC with the --enable-cld configure option.  Generation of "cld" instructions can be suppressed with the -mno-cld compiler option in this case.

       -mvzeroupper
           This option instructs GCC to emit a "vzeroupper" instruction before a transfer of control flow out of the function to minimize the AVX to SSE transition penalty as well as remove unnecessary "zeroupper" intrinsics.

       -mprefer-avx128
           This option instructs GCC to use 128-bit AVX instructions instead of 256-bit AVX instructions in the auto-vectorizer.

       -mcx16
           This option enables GCC to generate "CMPXCHG16B" instructions.  "CMPXCHG16B" allows for atomic operations on 128-bit double quadword (or oword) data types.  This is useful for high-resolution counters that can be updated by multiple processors (or cores).  This instruction is generated as part of atomic built-in functions: see __sync Builtins or __atomic Builtins for details.

       -msahf
           This option enables generation of "SAHF" instructions in 64-bit code.  Early Intel Pentium 4 CPUs with Intel 64 support, prior to the introduction of Pentium 4 G1 step in December 2005, lacked the "LAHF" and "SAHF" instructions which were supported by AMD64.  These are load and store instructions, respectively, for certain status flags.  In 64-bit mode, the "SAHF" instruction is used to optimize "fmod", "drem", and "remainder" built-in functions; see Other Builtins for details.

       -mmovbe
           This option enables use of the "movbe" instruction to implement "__builtin_bswap32" and "__builtin_bswap64".

       -mcrc32
           This option enables built-in functions "__builtin_ia32_crc32qi", "__builtin_ia32_crc32hi", "__builtin_ia32_crc32si" and "__builtin_ia32_crc32di" to generate the "crc32" machine instruction.

       -mrecip
           This option enables use of "RCPSS" and "RSQRTSS" instructions (and their vectorized variants "RCPPS" and "RSQRTPS") with an additional Newton-Raphson step to increase precision instead of "DIVSS" and "SQRTSS" (and their vectorized variants) for single-precision floating-point arguments.  These instructions are generated only when -funsafe-math-optimizations is enabled together with -finite-math-only and -fno-trapping-math.  Note that while the throughput of the sequence is higher than the throughput of the non-reciprocal instruction, the precision of the sequence can be decreased by up to 2 ulp (i.e. the inverse of 1.0 equals 0.99999994).

           Note that GCC implements "1.0f/sqrtf(x)" in terms of "RSQRTSS" (or "RSQRTPS") already with -ffast-math (or the above option combination), and doesn't need -mrecip.

           Also note that GCC emits the above sequence with additional Newton-Raphson step for vectorized single-float division and vectorized "sqrtf(x)" already with -ffast-math (or the above option combination), and doesn't need -mrecip.

       -mrecip=opt
           This option controls which reciprocal estimate instructions may be used.  opt is a comma-separated list of options, which may be preceded by a ! to invert the option:

           all Enable all estimate instructions.

           default
               Enable the default instructions, equivalent to -mrecip.

           none
               Disable all estimate instructions, equivalent to -mno-recip.

           div Enable the approximation for scalar division.

           vec-div
               Enable the approximation for vectorized division.

           sqrt
               Enable the approximation for scalar square root.

           vec-sqrt
               Enable the approximation for vectorized square root.

           So, for example, -mrecip=all,!sqrt enables all of the reciprocal approximations, except for square root.

       -mveclibabi=type
           Specifies the ABI type to use for vectorizing intrinsics using an external library.  Supported values for type are svml for the Intel short vector math library and acml for the AMD math core library.  To use this option, both -ftree-vectorize and -funsafe-math-optimizations have to be enabled, and an SVML or ACML ABI-compatible library must be specified at link time.

           GCC currently emits calls to "vmldExp2", "vmldLn2", "vmldLog102", "vmldLog102", "vmldPow2", "vmldTanh2", "vmldTan2", "vmldAtan2", "vmldAtanh2", "vmldCbrt2", "vmldSinh2", "vmldSin2", "vmldAsinh2", "vmldAsin2", "vmldCosh2", "vmldCos2", "vmldAcosh2", "vmldAcos2", "vmlsExp4", "vmlsLn4", "vmlsLog104", "vmlsLog104", "vmlsPow4", "vmlsTanh4", "vmlsTan4", "vmlsAtan4", "vmlsAtanh4", "vmlsCbrt4", "vmlsSinh4", "vmlsSin4", "vmlsAsinh4", "vmlsAsin4", "vmlsCosh4", "vmlsCos4", "vmlsAcosh4" and "vmlsAcos4" for corresponding function type when -mveclibabi=svml is used, and "__vrd2_sin", "__vrd2_cos", "__vrd2_exp", "__vrd2_log", "__vrd2_log2", "__vrd2_log10", "__vrs4_sinf", "__vrs4_cosf", "__vrs4_expf", "__vrs4_logf", "__vrs4_log2f", "__vrs4_log10f" and "__vrs4_powf" for the corresponding function type when -mveclibabi=acml is used.

       -mabi=name
           Generate code for the specified calling convention.  Permissible values are sysv for the ABI used on GNU/Linux and other systems, and ms for the Microsoft ABI.  The default is to use the Microsoft ABI when targeting Microsoft Windows and the SysV ABI on all other systems.  You can control this behavior for a specific function by using the function attribute ms_abi/sysv_abi.

       -mtls-dialect=type
           Generate code to access thread-local storage using the gnu or gnu2 conventions.  gnu is the conservative default; gnu2 is more efficient, but it may add compile- and run-time requirements that cannot be satisfied on all systems.

       -mpush-args
       -mno-push-args
           Use PUSH operations to store outgoing parameters.  This method is shorter and usually equally fast as method using SUB/MOV operations and is enabled by default.  In some cases disabling it may improve performance because of improved scheduling and reduced dependencies.

       -maccumulate-outgoing-args
           If enabled, the maximum amount of space required for outgoing arguments is computed in the function prologue.  This is faster on most modern CPUs because of reduced dependencies, improved scheduling and reduced stack usage when the preferred stack boundary is not equal to 2.  The drawback is a notable increase in code size.  This switch implies -mno-push-args.

       -mthreads
           Support thread-safe exception handling on MinGW.  Programs that rely on thread-safe exception handling must compile and link all code with the -mthreads option.  When compiling, -mthreads defines "-D_MT"; when linking, it links in a special thread helper library -lmingwthrd which cleans up per-thread exception-handling data.

       -mno-align-stringops
           Do not align the destination of inlined string operations.  This switch reduces code size and improves performance in case the destination is already aligned, but GCC doesn't know about it.

       -minline-all-stringops
           By default GCC inlines string operations only when the destination is known to be aligned to least a 4-byte boundary.  This enables more inlining and increases code size, but may improve performance of code that depends on fast "memcpy", "strlen", and "memset" for short lengths.

       -minline-stringops-dynamically
           For string operations of unknown size, use run-time checks with inline code for small blocks and a library call for large blocks.

       -mstringop-strategy=alg
           Override the internal decision heuristic for the particular algorithm to use for inlining string operations.  The allowed values for alg are:

           rep_byte
           rep_4byte
           rep_8byte
               Expand using i386 "rep" prefix of the specified size.

           byte_loop
           loop
           unrolled_loop
               Expand into an inline loop.

           libcall
               Always use a library call.

       -mmemcpy-strategy=strategy
           Override the internal decision heuristic to decide if "__builtin_memcpy" should be inlined and what inline algorithm to use when the expected size of the copy operation is known. strategy is a comma-separated list of alg:max_size:dest_align triplets.  alg is specified in -mstringop-strategy, max_size specifies the max byte size with which inline algorithm alg is allowed.  For the last triplet, the max_size must be "-1". The max_size of the triplets in the list must be specified in increasing order.  The minimal byte size for alg is 0 for the first triplet and "max_size + 1" of the preceding range.

       -mmemset-strategy=strategy
           The option is similar to -mmemcpy-strategy= except that it is to control "__builtin_memset" expansion.

       -momit-leaf-frame-pointer
           Don't keep the frame pointer in a register for leaf functions.  This avoids the instructions to save, set up, and restore frame pointers and makes an extra register available in leaf functions.  The option -fomit-leaf-frame-pointer removes the frame pointer for leaf functions, which might make debugging harder.

       -mtls-direct-seg-refs
       -mno-tls-direct-seg-refs
           Controls whether TLS variables may be accessed with offsets from the TLS segment register (%gs for 32-bit, %fs for 64-bit), or whether the thread base pointer must be added.  Whether or not this is valid depends on the operating system, and whether it maps the segment to cover the entire TLS area.

           For systems that use the GNU C Library, the default is on.

       -msse2avx
       -mno-sse2avx
           Specify that the assembler should encode SSE instructions with VEX prefix.  The option -mavx turns this on by default.

       -mfentry
       -mno-fentry
           If profiling is active (-pg), put the profiling counter call before the prologue.  Note: On x86 architectures the attribute "ms_hook_prologue" isn't possible at the moment for -mfentry and -pg.

       -m8bit-idiv
       -mno-8bit-idiv
           On some processors, like Intel Atom, 8-bit unsigned integer divide is much faster than 32-bit/64-bit integer divide.  This option generates a run-time check.  If both dividend and divisor are within range of 0 to 255, 8-bit unsigned integer divide is used instead of 32-bit/64-bit integer divide.

       -mavx256-split-unaligned-load
       -mavx256-split-unaligned-store
           Split 32-byte AVX unaligned load and store.

       -mstack-protector-guard=guard
           Generate stack protection code using canary at guard.  Supported locations are global for global canary or tls for per-thread canary in the TLS block (the default).  This option has effect only when -fstack-protector or -fstack-protector-all is specified.

       These -m switches are supported in addition to the above on x86-64 processors in 64-bit environments.

       -m32
       -m64
       -mx32
       -m16
           Generate code for a 16-bit, 32-bit or 64-bit environment.  The -m32 option sets "int", "long", and pointer types to 32 bits, and generates code that runs on any i386 system.

           The -m64 option sets "int" to 32 bits and "long" and pointer types to 64 bits, and generates code for the x86-64 architecture.  For Darwin only the -m64 option also turns off the -fno-pic and -mdynamic-no-pic options.

           The -mx32 option sets "int", "long", and pointer types to 32 bits, and generates code for the x86-64 architecture.

           The -m16 option is the same as -m32, except for that it outputs the ".code16gcc" assembly directive at the beginning of the assembly output so that the binary can run in 16-bit mode.

       -mno-red-zone
           Do not use a so-called "red zone" for x86-64 code.  The red zone is mandated by the x86-64 ABI; it is a 128-byte area beyond the location of the stack pointer that is not modified by signal or interrupt handlers and therefore can be used for temporary data without adjusting the stack pointer.  The flag -mno-red-zone disables this red zone.

       -mcmodel=small
           Generate code for the small code model: the program and its symbols must be linked in the lower 2 GB of the address space.  Pointers are 64 bits.  Programs can be statically or dynamically linked.  This is the default code model.

       -mcmodel=kernel
           Generate code for the kernel code model.  The kernel runs in the negative 2 GB of the address space.  This model has to be used for Linux kernel code.

       -mcmodel=medium
           Generate code for the medium model: the program is linked in the lower 2 GB of the address space.  Small symbols are also placed there.  Symbols with sizes larger than -mlarge-data-threshold are put into large data or BSS sections and can be located above 2GB.  Programs can be statically or dynamically linked.

       -mcmodel=large
           Generate code for the large model.  This model makes no assumptions about addresses and sizes of sections.

       -maddress-mode=long
           Generate code for long address mode.  This is only supported for 64-bit and x32 environments.  It is the default address mode for 64-bit environments.

       -maddress-mode=short
           Generate code for short address mode.  This is only supported for 32-bit and x32 environments.  It is the default address mode for 32-bit and x32 environments.


   Options for Code Generation Conventions
       These machine-independent options control the interface conventions used in code generation.

       Most of them have both positive and negative forms; the negative form of -ffoo is -fno-foo.  In the table below, only one of the forms is listed---the one that is not the default.  You can figure out the other form by either removing no- or adding it.

       -fbounds-check
           For front ends that support it, generate additional code to check that indices used to access arrays are within the declared range.  This is currently only supported by the Java and Fortran front ends, where this option defaults to true and false respectively.

       -fstack-reuse=reuse-level
           This option controls stack space reuse for user declared local/auto variables and compiler generated temporaries.  reuse_level can be all, named_vars, or none. all enables stack reuse for all local variables and temporaries, named_vars enables the reuse only for user defined local variables with names, and none disables stack reuse completely. The default value is all. The option is needed when the program extends the lifetime of a scoped local variable or a compiler generated temporary beyond the end point defined by the language.  When a lifetime of a variable ends, and if the variable lives in memory, the optimizing compiler has the freedom to reuse its stack space with other temporaries or scoped local variables whose live range does not overlap with it. Legacy code extending local lifetime will likely to break with the stack reuse optimization.

           For example,

                      int *p;
                      {
                        int local1;

                        p = &local1;
                        local1 = 10;
                        ....
                      }
                      {
                         int local2;
                         local2 = 20;
                         ...
                      }

                      if (*p == 10)  // out of scope use of local1
                        {

                        }

           Another example:

                      struct A
                      {
                          A(int k) : i(k), j(k) { }
                          int i;
                          int j;
                      };

                      A *ap;

                      void foo(const A& ar)
                      {
                         ap = &ar;
                      }

                      void bar()
                      {
                         foo(A(10)); // temp object's lifetime ends when foo returns

                         {
                           A a(20);
                           ....
                         }
                         ap->i+= 10;  // ap references out of scope temp whose space
                                      // is reused with a. What is the value of ap->i?
                      }

           The lifetime of a compiler generated temporary is well defined by the C++ standard. When a lifetime of a temporary ends, and if the temporary lives in memory, the optimizing compiler has the freedom to reuse its stack space with other temporaries or scoped local variables whose live range does not overlap with it. However some of the legacy code relies on the behavior of older compilers in which temporaries' stack space is not reused, the aggressive stack reuse can lead to runtime errors. This option is used to control the temporary stack reuse optimization.

       -ftrapv
           This option generates traps for signed overflow on addition, subtraction, multiplication operations.

       -fwrapv
           This option instructs the compiler to assume that signed arithmetic overflow of addition, subtraction and multiplication wraps around using twos-complement representation.  This flag enables some optimizations and disables others.  This option is enabled by default for the Java front end, as required by the Java language specification.

       -fexceptions
           Enable exception handling.  Generates extra code needed to propagate exceptions.  For some targets, this implies GCC generates frame unwind information for all functions, which can produce significant data size overhead, although it does not affect execution.  If you do not specify this option, GCC enables it by default for languages like C++ that normally require exception handling, and disables it for languages like C that do not normally require it.  However, you may need to enable this option when compiling C code that needs to interoperate properly with exception handlers written in C++.  You may also wish to disable this option if you are compiling older C++ programs that don't use exception handling.

       -fnon-call-exceptions
           Generate code that allows trapping instructions to throw exceptions.  Note that this requires platform-specific runtime support that does not exist everywhere.  Moreover, it only allows trapping instructions to throw exceptions, i.e. memory references or floating-point instructions.  It does not allow exceptions to be thrown from arbitrary signal handlers such as "SIGALRM".

       -fdelete-dead-exceptions
           Consider that instructions that may throw exceptions but don't otherwise contribute to the execution of the program can be optimized away.  This option is enabled by default for the Ada front end, as permitted by the Ada language specification.  Optimization passes that cause dead exceptions to be removed are enabled independently at different optimization levels.

       -funwind-tables
           Similar to -fexceptions, except that it just generates any needed static data, but does not affect the generated code in any other way.  You normally do not need to enable this option; instead, a language processor that needs this handling enables it on your behalf.

       -fasynchronous-unwind-tables
           Generate unwind table in DWARF 2 format, if supported by target machine.  The table is exact at each instruction boundary, so it can be used for stack unwinding from asynchronous events (such as debugger or garbage collector).

       -fno-gnu-unique
           On systems with recent GNU assembler and C library, the C++ compiler uses the "STB_GNU_UNIQUE" binding to make sure that definitions of template static data members and static local variables in inline functions are unique even in the presence of "RTLD_LOCAL"; this is necessary to avoid problems with a library used by two different "RTLD_LOCAL" plugins depending on a definition in one of them and therefore disagreeing with the other one about the binding of the symbol.  But this causes "dlclose" to be ignored for affected DSOs; if your program relies on reinitialization of a DSO via "dlclose" and "dlopen", you can use -fno-gnu-unique.

       -fpcc-struct-return
           Return "short" "struct" and "union" values in memory like longer ones, rather than in registers.  This convention is less efficient, but it has the advantage of allowing intercallability between GCC-compiled files and files compiled with other compilers, particularly the Portable C Compiler (pcc).

           The precise convention for returning structures in memory depends on the target configuration macros.

           Short structures and unions are those whose size and alignment match that of some integer type.

           Warning: code compiled with the -fpcc-struct-return switch is not binary compatible with code compiled with the -freg-struct-return switch.  Use it to conform to a non-default application binary interface.

       -freg-struct-return
           Return "struct" and "union" values in registers when possible.  This is more efficient for small structures than -fpcc-struct-return.

           If you specify neither -fpcc-struct-return nor -freg-struct-return, GCC defaults to whichever convention is standard for the target.  If there is no standard convention, GCC defaults to -fpcc-struct-return, except on targets where GCC is the principal compiler.  In those cases, we can choose the standard, and we chose the more efficient register return alternative.

           Warning: code compiled with the -freg-struct-return switch is not binary compatible with code compiled with the -fpcc-struct-return switch.  Use it to conform to a non-default application binary interface.

       -fshort-enums
           Allocate to an "enum" type only as many bytes as it needs for the declared range of possible values.  Specifically, the "enum" type is equivalent to the smallest integer type that has enough room.

           Warning: the -fshort-enums switch causes GCC to generate code that is not binary compatible with code generated without that switch.  Use it to conform to a non-default application binary interface.

       -fshort-double
           Use the same size for "double" as for "float".

           Warning: the -fshort-double switch causes GCC to generate code that is not binary compatible with code generated without that switch.  Use it to conform to a non-default application binary interface.

       -fshort-wchar
           Override the underlying type for wchar_t to be short unsigned int instead of the default for the target.  This option is useful for building programs to run under WINE.

           Warning: the -fshort-wchar switch causes GCC to generate code that is not binary compatible with code generated without that switch.  Use it to conform to a non-default application binary interface.

       -fno-common
           In C code, controls the placement of uninitialized global variables.  Unix C compilers have traditionally permitted multiple definitions of such variables in different compilation units by placing the variables in a common block.  This is the behavior specified by -fcommon, and is the default for GCC on most targets.  On the other hand, this behavior is not required by ISO C, and on some targets may carry a speed or code size penalty on variable references.  The -fno-common option specifies that the compiler should place uninitialized global variables in the data section of the object file, rather than generating them as common blocks.  This has the effect that if the same variable is declared (without "extern") in two different compilations, you get a multiple-definition error when you link them.  In this case, you must compile with -fcommon instead.  Compiling with -fno-common is useful on targets for which it provides better performance, or if you wish to verify that the program will work on other systems that always treat uninitialized variable declarations this way.

       -fno-ident
           Ignore the #ident directive.

       -finhibit-size-directive
           Don't output a ".size" assembler directive, or anything else that would cause trouble if the function is split in the middle, and the two halves are placed at locations far apart in memory.  This option is used when compiling crtstuff.c; you should not need to use it for anything else.

       -fverbose-asm
           Put extra commentary information in the generated assembly code to make it more readable.  This option is generally only of use to those who actually need to read the generated assembly code (perhaps while debugging the compiler itself).

           -fno-verbose-asm, the default, causes the extra information to be omitted and is useful when comparing two assembler files.

       -frecord-gcc-switches
           This switch causes the command line used to invoke the compiler to be recorded into the object file that is being created.  This switch is only implemented on some targets and the exact format of the recording is target and binary file format dependent, but it usually takes the form of a section containing ASCII text.  This switch is related to the -fverbose-asm switch, but that switch only records information in the assembler output file as comments, so it never reaches the object file.  See also -grecord-gcc-switches for another way of storing compiler options into the object file.

       -fpic
           Generate position-independent code (PIC) suitable for use in a shared library, if supported for the target machine.  Such code accesses all constant addresses through a global offset table (GOT).  The dynamic loader resolves the GOT entries when the program starts (the dynamic loader is not part of GCC; it is part of the operating system).  If the GOT size for the linked executable exceeds a machine-specific maximum size, you get an error message from the linker indicating that -fpic does not work; in that case, recompile with -fPIC instead.  (These maximums are 8k on the SPARC and 32k on the m68k and RS/6000.  The 386 has no such limit.)

           Position-independent code requires special support, and therefore works only on certain machines.  For the 386, GCC supports PIC for System V but not for the Sun 386i.  Code generated for the IBM RS/6000 is always position-independent.

           When this flag is set, the macros "__pic__" and "__PIC__" are defined to 1.

       -fPIC
           If supported for the target machine, emit position-independent code, suitable for dynamic linking and avoiding any limit on the size of the global offset table.  This option makes a difference on the m68k, PowerPC and SPARC.

           Position-independent code requires special support, and therefore works only on certain machines.

           When this flag is set, the macros "__pic__" and "__PIC__" are defined to 2.

       -fpie
       -fPIE
           These options are similar to -fpic and -fPIC, but generated position independent code can be only linked into executables.  Usually these options are used when -pie GCC option is used during linking.

           -fpie and -fPIE both define the macros "__pie__" and "__PIE__".  The macros have the value 1 for -fpie and 2 for -fPIE.

       -fno-jump-tables
           Do not use jump tables for switch statements even where it would be more efficient than other code generation strategies.  This option is of use in conjunction with -fpic or -fPIC for building code that forms part of a dynamic linker and cannot reference the address of a jump table.  On some targets, jump tables do not require a GOT and this option is not needed.

       -ffixed-reg
           Treat the register named reg as a fixed register; generated code should never refer to it (except perhaps as a stack pointer, frame pointer or in some other fixed role).

           reg must be the name of a register.  The register names accepted are machine-specific and are defined in the "REGISTER_NAMES" macro in the machine description macro file.

           This flag does not have a negative form, because it specifies a three-way choice.

       -fcall-used-reg
           Treat the register named reg as an allocable register that is clobbered by function calls.  It may be allocated for temporaries or variables that do not live across a call.  Functions compiled this way do not save and restore the register reg.

           It is an error to use this flag with the frame pointer or stack pointer.  Use of this flag for other registers that have fixed pervasive roles in the machine's execution model produces disastrous results.

           This flag does not have a negative form, because it specifies a three-way choice.

       -fcall-saved-reg
           Treat the register named reg as an allocable register saved by functions.  It may be allocated even for temporaries or variables that live across a call.  Functions compiled this way save and restore the register reg if they use it.

           It is an error to use this flag with the frame pointer or stack pointer.  Use of this flag for other registers that have fixed pervasive roles in the machine's execution model produces disastrous results.

           A different sort of disaster results from the use of this flag for a register in which function values may be returned.

           This flag does not have a negative form, because it specifies a three-way choice.

       -fpack-struct[=n]
           Without a value specified, pack all structure members together without holes.  When a value is specified (which must be a small power of two), pack structure members according to this value, representing the maximum alignment (that is, objects with default alignment requirements larger than this are output potentially unaligned at the next fitting location.

           Warning: the -fpack-struct switch causes GCC to generate code that is not binary compatible with code generated without that switch.  Additionally, it makes the code suboptimal.  Use it to conform to a non-default application binary interface.

       -finstrument-functions
           Generate instrumentation calls for entry and exit to functions.  Just after function entry and just before function exit, the following profiling functions are called with the address of the current function and its call site.  (On some platforms, "__builtin_return_address" does not work beyond the current function, so the call site information may not be available to the profiling functions otherwise.)

                   void __cyg_profile_func_enter (void *this_fn,
                                                  void *call_site);
                   void __cyg_profile_func_exit  (void *this_fn,
                                                  void *call_site);

           The first argument is the address of the start of the current function, which may be looked up exactly in the symbol table.

           This instrumentation is also done for functions expanded inline in other functions.  The profiling calls indicate where, conceptually, the inline function is entered and exited.  This means that addressable versions of such functions must be available.  If all your uses of a function are expanded inline, this may mean an additional expansion of code size.  If you use extern inline in your C code, an addressable version of such functions must be provided.  (This is normally the case anyway, but if you get lucky and the optimizer always expands the functions inline, you might have gotten away without providing static copies.)

           A function may be given the attribute "no_instrument_function", in which case this instrumentation is not done.  This can be used, for example, for the profiling functions listed above, high-priority interrupt routines, and any functions from which the profiling functions cannot safely be called (perhaps signal handlers, if the profiling routines generate output or allocate memory).

       -finstrument-functions-exclude-file-list=file,file,...
           Set the list of functions that are excluded from instrumentation (see the description of "-finstrument-functions").  If the file that contains a function definition matches with one of file, then that function is not instrumented.  The match is done on substrings: if the file parameter is a substring of the file name, it is considered to be a match.

           For example:

                   -finstrument-functions-exclude-file-list=/bits/stl,include/sys

           excludes any inline function defined in files whose pathnames contain "/bits/stl" or "include/sys".

           If, for some reason, you want to include letter ',' in one of sym, write ','. For example, "-finstrument-functions-exclude-file-list=',,tmp'" (note the single quote surrounding the option).

       -finstrument-functions-exclude-function-list=sym,sym,...
           This is similar to "-finstrument-functions-exclude-file-list", but this option sets the list of function names to be excluded from instrumentation.  The function name to be matched is its user-visible name, such as "vector<int> blah(const vector<int> &)", not the internal mangled name (e.g., "_Z4blahRSt6vectorIiSaIiEE").  The match is done on substrings: if the sym parameter is a substring of the function name, it is considered to be a match.  For C99 and C++ extended identifiers, the function name must be given in UTF-8, not using universal character names.

       -fstack-check
           Generate code to verify that you do not go beyond the boundary of the stack.  You should specify this flag if you are running in an environment with multiple threads, but you only rarely need to specify it in a single-threaded environment since stack overflow is automatically detected on nearly all systems if there is only one stack.

           Note that this switch does not actually cause checking to be done; the operating system or the language runtime must do that.  The switch causes generation of code to ensure that they see the stack being extended.

           You can additionally specify a string parameter: "no" means no checking, "generic" means force the use of old-style checking, "specific" means use the best checking method and is equivalent to bare -fstack-check.

           Old-style checking is a generic mechanism that requires no specific target support in the compiler but comes with the following drawbacks:

           1.  Modified allocation strategy for large objects: they are always allocated dynamically if their size exceeds a fixed threshold.

           2.  Fixed limit on the size of the static frame of functions: when it is topped by a particular function, stack checking is not reliable and a warning is issued by the compiler.

           3.  Inefficiency: because of both the modified allocation strategy and the generic implementation, code performance is hampered.

           Note that old-style stack checking is also the fallback method for "specific" if no target support has been added in the compiler.

       -fstack-limit-register=reg
       -fstack-limit-symbol=sym
       -fno-stack-limit
           Generate code to ensure that the stack does not grow beyond a certain value, either the value of a register or the address of a symbol.  If a larger stack is required, a signal is raised at run time.  For most targets, the signal is raised before the stack overruns the boundary, so it is possible to catch the signal without taking special precautions.

           For instance, if the stack starts at absolute address 0x80000000 and grows downwards, you can use the flags -fstack-limit-symbol=__stack_limit and -Wl,--defsym,__stack_limit=0x7ffe0000 to enforce a stack limit of 128KB.  Note that this may only work with the GNU linker.

       -fsplit-stack
           Generate code to automatically split the stack before it overflows.  The resulting program has a discontiguous stack which can only overflow if the program is unable to allocate any more memory.  This is most useful when running threaded programs, as it is no longer necessary to calculate a good stack size to use for each thread.  This is currently only implemented for the i386 and x86_64 back ends running GNU/Linux.

           When code compiled with -fsplit-stack calls code compiled without -fsplit-stack, there may not be much stack space available for the latter code to run.  If compiling all code, including library code, with -fsplit-stack is not an option, then the linker can fix up these calls so that the code compiled without -fsplit-stack always has a large stack.  Support for this is implemented in the gold linker in GNU binutils release 2.21 and later.

       -fleading-underscore
           This option and its counterpart, -fno-leading-underscore, forcibly change the way C symbols are represented in the object file.  One use is to help link with legacy assembly code.

           Warning: the -fleading-underscore switch causes GCC to generate code that is not binary compatible with code generated without that switch.  Use it to conform to a non-default application binary interface.  Not all targets provide complete support for this switch.

       -ftls-model=model
           Alter the thread-local storage model to be used.  The model argument should be one of "global-dynamic", "local-dynamic", "initial-exec" or "local-exec".  Note that the choice is subject to optimization: the compiler may use a more efficient model for symbols not visible outside of the translation unit, or if -fpic is not given on the command line.

           The default without -fpic is "initial-exec"; with -fpic the default is "global-dynamic".

       -fvisibility=default|internal|hidden|protected
           Set the default ELF image symbol visibility to the specified option---all symbols are marked with this unless overridden within the code.  Using this feature can very substantially improve linking and load times of shared object libraries, produce more optimized code, provide near-perfect API export and prevent symbol clashes.  It is strongly recommended that you use this in any shared objects you distribute.

           Despite the nomenclature, "default" always means public; i.e., available to be linked against from outside the shared object.  "protected" and "internal" are pretty useless in real-world usage so the only other commonly used option is "hidden".  The default if -fvisibility isn't specified is "default", i.e., make every symbol public---this causes the same behavior as previous versions of GCC.

           A good explanation of the benefits offered by ensuring ELF symbols have the correct visibility is given by "How To Write Shared Libraries" by Ulrich Drepper (which can be found at <http://people.redhat.com/~drepper/>)---however a superior solution made possible by this option to marking things hidden when the default is public is to make the default hidden and mark things public.  This is the norm with DLLs on Windows and with -fvisibility=hidden and "__attribute__ ((visibility("default")))" instead of "__declspec(dllexport)" you get almost identical semantics with identical syntax.  This is a great boon to those working with cross-platform projects.

           For those adding visibility support to existing code, you may find #pragma GCC visibility of use.  This works by you enclosing the declarations you wish to set visibility for with (for example) #pragma GCC visibility push(hidden) and #pragma GCC visibility pop.  Bear in mind that symbol visibility should be viewed as part of the API interface contract and thus all new code should always specify visibility when it is not the default; i.e., declarations only for use within the local DSO should always be marked explicitly as hidden as so to avoid PLT indirection overheads---making this abundantly clear also aids readability and self-documentation of the code.  Note that due to ISO C++ specification requirements, "operator new" and "operator delete" must always be of default visibility.

           Be aware that headers from outside your project, in particular system headers and headers from any other library you use, may not be expecting to be compiled with visibility other than the default.  You may need to explicitly say #pragma GCC visibility push(default) before including any such headers.

           extern declarations are not affected by -fvisibility, so a lot of code can be recompiled with -fvisibility=hidden with no modifications.  However, this means that calls to "extern" functions with no explicit visibility use the PLT, so it is more effective to use "__attribute ((visibility))" and/or "#pragma GCC visibility" to tell the compiler which "extern" declarations should be treated as hidden.

           Note that -fvisibility does affect C++ vague linkage entities. This means that, for instance, an exception class that is be thrown between DSOs must be explicitly marked with default visibility so that the type_info nodes are unified between the DSOs.

           An overview of these techniques, their benefits and how to use them is at <http://gcc.gnu.org/wiki/Visibility>.

       -fstrict-volatile-bitfields
           This option should be used if accesses to volatile bit-fields (or other structure fields, although the compiler usually honors those types anyway) should use a single access of the width of the field's type, aligned to a natural alignment if possible.  For example, targets with memory-mapped peripheral registers might require all such accesses to be 16 bits wide; with this flag you can declare all peripheral bit-fields as "unsigned short" (assuming short is 16 bits on these targets) to force GCC to use 16-bit accesses instead of, perhaps, a more efficient 32-bit access.

           If this option is disabled, the compiler uses the most efficient instruction.  In the previous example, that might be a 32-bit load instruction, even though that accesses bytes that do not contain any portion of the bit-field, or memory-mapped registers unrelated to the one being updated.

           In some cases, such as when the "packed" attribute is applied to a structure field, it may not be possible to access the field with a single read or write that is correctly aligned for the target machine.  In this case GCC falls back to generating multiple accesses rather than code that will fault or truncate the result at run time.

           Note:  Due to restrictions of the C/C++11 memory model, write accesses are not allowed to touch non bit-field members.  It is therefore recommended to define all bits of the field's type as bit-field members.

           The default value of this option is determined by the application binary interface for the target processor.

       -fsync-libcalls
           This option controls whether any out-of-line instance of the "__sync" family of functions may be used to implement the C++11 "__atomic" family of functions.

           The default value of this option is enabled, thus the only useful form of the option is -fno-sync-libcalls.  This option is used in the implementation of the libatomic runtime library.

ENVIRONMENT
       GCC_EXEC_PREFIX
           If GCC_EXEC_PREFIX is set, it specifies a prefix to use in the names of the subprograms executed by the compiler.  No slash is added when this prefix is combined with the name of a subprogram, but you can specify a prefix that ends with a slash if you wish.

           If GCC_EXEC_PREFIX is not set, GCC attempts to figure out an appropriate prefix to use based on the pathname it is invoked with.

           If GCC cannot find the subprogram using the specified prefix, it tries looking in the usual places for the subprogram.

           The default value of GCC_EXEC_PREFIX is prefix/lib/gcc/ where prefix is the prefix to the installed compiler. In many cases prefix is the value of "prefix" when you ran the configure script.

           Other prefixes specified with -B take precedence over this prefix.

           This prefix is also used for finding files such as crt0.o that are used for linking.

           In addition, the prefix is used in an unusual way in finding the directories to search for header files.  For each of the standard directories whose name normally begins with /usr/local/lib/gcc (more precisely, with the value of GCC_INCLUDE_DIR), GCC tries replacing that beginning with the specified prefix to produce an alternate directory name.  Thus, with -Bfoo/, GCC searches foo/bar just before it searches the standard directory /usr/local/lib/bar.  If a standard directory begins with the configured prefix then the value of prefix is replaced by GCC_EXEC_PREFIX when looking for header files.

       COMPILER_PATH
           The value of COMPILER_PATH is a colon-separated list of directories, much like PATH.  GCC tries the directories thus specified when searching for subprograms, if it can't find the subprograms using GCC_EXEC_PREFIX.

       LIBRARY_PATH
           The value of LIBRARY_PATH is a colon-separated list of directories, much like PATH.  When configured as a native compiler, GCC tries the directories thus specified when searching for special linker files, if it can't find them using GCC_EXEC_PREFIX.  Linking using GCC also uses these directories when searching for ordinary libraries for the -l option (but directories specified with -L come first).

           CPATH specifies a list of directories to be searched as if specified with -I, but after any paths given with -I options on the command line.  This environment variable is used regardless of which language is being preprocessed.


